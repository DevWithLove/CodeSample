Course Overview
Course Overview
Hi everyone! My name is James Wilson, and welcome to my course, iOS Auto Layout: Fundamentals. I am an iOS developer at Rodale, Inc. Auto Layout offers an incredible way to build dynamic interfaces for iPhones and iPads. However, there is a lot of mystery surrounding the technology. In this course, we are going to demystify Auto Layout and give you full control over it so you can build some truly unique interfaces. Some of the major topics that we will cover include an in-depth look at constraints, the fundamental building blocks for Auto Layout, building constraints by using Interface Builder and NSLayoutConstraint, the layout process and how you can hook into each step, controlling how constraints are tied to your own custom views, avoiding ambiguous views with content hugging and compression resistance, and, finally, simplifying the use of Auto Layout by activating constraints, using anchors, or leveraging the UIStackView. By the end of this course, you will have a firm understanding of how Auto Layout works under the hood. This will put you in control of Auto Layout. Before beginning the course, you should be familiar with using XCode and Interface Building. In addition, the code used in this course is in Swift, but you should at least be comfortable with working with Swift, Objective-C, or C# with Xamarin. I hope you'll join me on this journey to learn Auto Layout with the iOS Auto Layout: Fundamentals course at Pluralsight.

Introducing Auto Layout
Too Many Screens
Welcome to iOS Auto Layout: Fundamentals. When we first started with iOS, we just had the original iPhone, and it was very simple, easy to design for. As time went on, they released the iPhone 5 with the larger screen, and our user interfaces had to adapt and adjust to the change. And since then, things have only gotten more complicated. We've had the introduction of the iPhone 6 and the 6+, which for were 4. 7- and 5. 5-inch devices. You can put the phone into landscape mode, which causes even more layout issues with your user interfaces. And then when you throw in the iPad, the possibilities are endless. Now is there a way to simplify our lives? Well, there is, and that's with Auto Layout. Auto Layout is a constraint-based system, and using these constraints, you can easily build flexible user interfaces that can adapt to the device and the device's orientation. And learning everything there is to know about Auto Layout will allow you to build amazing user interfaces that can adapt to the current line of devices out on the market and future devices that have not even been released yet.

Who Is this Course For?
Who is this course for? Well, it's for both new and experienced iOS developers. If you're just getting started, Auto Layout could be a frustrating technology to use because if you truly don't understand how everything is working under the hood, a lot of it just seems like magic, or it seems like random decisions are being made that you just continuously find irritating. And that's not the case. And even for experienced iOS developers, if you have been using Auto Layout, this course will help clarify a lot of things, answer questions that you may have had about this technology. So as long as you're comfortable with using Xcode and Interface Builder, and you have some experience in Objective-C or Swift or even the Xamarin C#, you should be able to follow along in this course easily. All the code in this course, though, will be written in Swift. So if you're not familiar with it, there are definitely some courses on Pluralsight you can check out to get yourself up to speed.

Course Overview
There's a lot of great material to cover in this course. So in this module, we're actually first going to introduce you to some of the older methods that were around before Auto Layout existed. And we're going to discuss some of the advantages and disadvantages to them and how Auto Layout solves a lot of issues making it easier to create these dynamic user interfaces. Then in the second module, we're going to dive in and look at all the constraints. And that's what you do in Auto Layout--you create constraints between your views. So we're going to take a look at all the constraints. We're going to break down a single constraint so we know what every piece is doing and how you can control that. And we're also going to offer you some tips on how to better work with Auto Layout, some goals that you want to achieve because it is a different way of thinking. And so it's definitely important to lay that groundwork. Then in the next module, we'll be going over Interface Builder's tools and NSLayoutConstraint. And essentially with these two tools--Interface Builder and NSLayoutConstraint--you can accomplish the same thing, and that is one of the more challenging aspects with Auto Layout. There are so many ways to do the same thing, that can become overwhelming. And so we're going to cover a lot of good material in that course leaving you with a good knowledge about both of these so you can create some truly unique interfaces. Then we're going to jump into the rendering pipeline. And what do I mean by the rendering pipeline? Well, when you lay out constraints, when are they calculated? When is everything figured out? And can you update those depending on your circumstances? Well the answer is Yes, and we're going to be looking at every phase of the rendering pipeline and going over how and when you should update your constraints or even manually set frames and in addition do some custom drawing as well. It's very powerful once you know the steps, they're very easy to remember. Then in the module after that, we are going to go and make a custom view. And when we do this, we are going to break apart the view and how constraints work with the view. And by that I mean you'll see that a view has attributes like top, leading, trailing, and bottom. And these always seem to be set to the edge of the frame, but that's not actually the case. So by creating this custom view, this will give us the opportunity to see how does Auto Layout determine how it connects to a view? And this is something you have complete control over. And we're going to go into it in-depth so by the end of it, you will know how to set every type of constraint within your own custom controls, and they will work properly with Auto Layout. In the module after that, we're going to go into a topic called content hugging and compression resistance. And this really does build on the prior modules of rendering pipeline and custom view. And the knowledge that you gain from those will give us an easy way to understand these two concepts because what these two concepts will do is they're essentially a tie breaker. If for some reason you have constraints set up in your view and Auto Layout doesn't know what to do with them, this is your opportunity to set a couple of priorities and give one view leverage over others. It's really cool, and once you know it, it's extremely useful because it's an issue that you're going to run into time and time again, these tie breakers, and then you'll be equipped to be able to handle them knowing you're going to get the layout that you want. And then when all is said and done, the final module is all about simplifying your life and working with Auto Layout. In iOS 8 and iOS 9, Apple has added a couple of cool additions to the Auto Layout system, which makes it really easy to work with constraints. And so we'll look at the active property on NSLayoutConstraint. We'll look at the new anchors that were created in iOS 9, which really will simplify your code base if you're working with NSLayoutConstraint API. And then the UIStackView, which is perfect if you have a simple horizontal and vertical layout. You can use UIStackViews, and you don't even need to use any constraints. However, it's important to understand the fundamentals of Auto Layout to fully grasp how the UIStackView works, which is one of the reasons why we're saving it until the end. And by the end of this course, there is one thing for certain--you will have control of Auto Layout. You will have a fundamental understanding of how everything is working underneath the hood so there are very little surprises as you go and try to build your user interfaces. So this puts you in control. So now there's a lot of exciting material to cover. So let's jump in and see what we're going to cover in this first module.

Module Overview
So in this module, we're going to go over what was used before Auto Layout. And then we're going to go into the benefits of Auto Layout, and there are a lot of benefits. And it's definitely worth the time in learning it. Then we're going to quickly just review the demo project that we're building, and also set up the demo project, downloading assets from GitHub and getting everything ready in Xcode for the rest of the course. But, first, let's take a look at auto-resizing masks and frames.

Autoresizing Masks and Frames
So let's take a look at life before Auto Layout. And the first technology we're going to look at is auto-resizing masks. And on the left here, you can see if you had Auto Layout disabled in Interface Builder, you would see this auto-resizing menu. And what it allowed you to do was it allowed you to create flexible views using a spring and strut mechanism. And so it allowed you to make certain edges more flexible, and as the window on your Mac app grew or you rotated the device on the iPhone to landscape mode, it would extend the view size up. But one of the major downfalls was it couldn't handle complex view relationships. And what do I mean by that? Well, the springs and struts will work as long as it's within child views of a view. But if you need to do anything outside of that, connect two different views in two different view hierarchies, it falls apart. You just can't do it. In fact, in Auto Layout, you can. So it's one of the major advantages of it. Auto-resizing masks essentially are just very---they're too simple. They're too simple for the needs of all the different devices we have out there today. And there's proof by that because Auto Layout is used to mimic the springs and struts. If you are using auto-resizing masks, anything that could have been done by auto-resizing masks can easily be done with constraints. And then the Auto Layout constraints can do so much more on top of that. So if auto-resizing masks weren't going to suit your needs, then what else was there? Well there are also frame calculations. I think this has more disadvantages than it does advantages because they're not very adaptable. If they're not coded properly and then Apple releases a new device, there's a good chance that your user interface could have bugs on one of the devices. And it's very hard to maintain too because you could go ahead and right a bunch of frame code, a bunch of frame calculations with the X, Y, and width and height, and all of that, and then the developers coming in after you, if they're any issues with it or they need to upgrade it, they then need to sit there and figure out all the calculations. They need to understand what's going on with your arithmetic, and that can become very time consuming, which also leads to another issue--debugging frame calculations can be more challenging. And now can it be adaptable? Can it be easy to maintain? And can it be easy to debug? Of course it can. But Auto Layout is easier, and it leads to less issues overall. With that being said, let's take a look at some of the benefits that Auto Layout will give you over auto-resizing masks and frame calculations.

The Benefits of Auto Layout
So what are the benefits to Auto Layout? One, it allows you to be more productive. Once you get comfortable with laying out constraints, suddenly building your user interfaces is a lot less work. You can make them very adaptable, and you can make them very flexible. And both of these lead to better maintainability because as long as your team understands how Auto Layout works, it's much easier to go and view the constraints especially in Interface Builder to see how the UI is being constructed. Those aren't the only benefits though. Let's talk about localization. You'll see in the next module that Auto Layout has this concept about leading and trailing instead of left and right edges of your device. And what happens when you build your user interfaces using this leading and trailing mechanism is suddenly your app can easily adapt to users that are using a language that goes from right to left. Auto Layout will be smart enough to know to reverse your whole user interface so it makes sense for those particular users. You can't get that with auto-resizing masks or regular frames. And then there's also the benefit of accessibility, which we're not going to really be diving into in this course. But, regardless, the very act of learning Auto Layout and making your views that flexible allows suddenly for things like dynamic text where the user can make the text smaller or larger in the app through their system settings. And the user interface will just lay out properly for them. And it doesn't involve any extra work on your part short of using dynamic text. So that's another huge benefit for using Auto Layout. And then, finally, one of the coolest new features for iOS 9 was the iPad multitasking mode. Now can you build an app that is iPad multitasking capable without Auto Layout? Yes, you can. However, it's extremely difficult, and doing it with Auto Layout will save you so much time, and you'll get such a better result for your users. But that's not all, and this is by far one of the best reasons to use it, and that is not only is Auto Layout on iOS, but it's also on tvOS and OS X. Now the fundamental principles translate very well to all three of these, and then there are some subtle differences between the platforms. For instance, iOS and tvOS use a UI view, and OS X uses an NS view. But the fundamental aspects of Auto Layout work across all three of these operating systems. So you get a lot by learning Auto Layout. If you learn it, it has huge returns. So it's awesome!

What Will You Build?
So let's take a look at some of the demo projects we're going to be building throughout this course. First, the one that we'll be using throughout the majority of the course is our Collaborate project. And you can think of it perhaps as a professional social networking app where you could collaborate with other people from other social networks. And what we're going to do with this app is we're going to build the splash screen for it, and we're going to do that in both Interface Builder and using NSLayoutConstraint object, and you'll see how we can quickly lay out a few constraints and have this splash screen be adaptable to both the iPhone and the iPad. So it's really powerful. And then we're going to step it up a bit, and we're going to build a menu screen. So we're going to set up our project as a master detail iOS application, and this menu screen will function properly on an iPhone or on an iPad. And we're going to build a menu screen using Interface Builder. And then later in the course, we're going to leverage the UIStackView to just remove all constraints and build it with that. So it's really cool. And both of these examples just show you the power and flexibility of Auto Layout in general. And then in addition to that, we're going to build a custom profile view for our Collaborate project when we look at building custom views with Auto Layout. And through this, we'll work between our custom viewing code and Interface Builder to see how we can actually control all the different types of constraints that can be applied to a view. So it's really cool, really powerful. And it'll be a lot of fun! And then during the controlling Auto Layout's rendering pipeline, we're going to take a step away from the Collaborate project and actually build a small Venn diagram. And so through this, we'll build the Venn diagram in Interface Builder, and then in code we'll see how we can update it and leverage Auto Layout to control how the UI gets updated depending on what we code. So it'll be a very cool project. And then, finally, when it makes sense, we'll be leveraging Xcode's Playground to do some live coding so you can get a good real-time sense of what is happening in Auto Layout. So we have plenty of cool projects. There's so much work to do. So let's go and grab our image assets from GitHub for our Collaborate project.

Setting up the Project
In this video, let's set up our Collaborate project. And we'll be using this project throughout most of the course. Now for your convenience, there is a GitHub repository that has a bunch of image files that you can use to follow along with the course. And if you just jump into the Images folder here, you can see it's just a bunch of social network-type images and images of people that we'll be using. And you don't even need to clone the repository. You can go ahead and download it. And you can find it at this URL. Go ahead and just download the zip at Downloads. Now I have my images here. I'm going to move this off to the side. And I already have Xcode open as well. I'm going to minimize that. And I'll select Create a new Xcode project. And we want the Master-Detail Application. So go ahead and select Next. And call it Collaborate. And keep going. We want Swift. And now in our Assets folder here, we can just go ahead and open up the Images folder and hit Command+A, and drag and drop. And there you go. Now we have all of the images that we need to work with throughout the course. And you can see on the Master Detail storyboard that we have this setup right here with our Master View Controller and our Detail View Controller, and we'll get to those later in a future module. For now, we just wanted to get you the assets to be able to start building our Collaborate app.

Summary
So this was a nice and quick module. We first did a course overview so you know what you're learning throughout this whole course. Then we took a look at what was before Auto Layout with auto-resizing masks and simple frame calculations on your UI views. And we looked at some of the disadvantages that both of these have in respect to Auto Layout. And then we took a good in-depth look at the benefits of using Auto Layout, which there are so many from localization to accessibility and the technologies on multiple platforms between iOS, tvOS, and OS X. So it's cool! It's just really cool! Finally, we reviewed some of the projects we're going to be building throughout the course and set up our Collaborate project by grabbing image assets from GitHub. And now let's to go the next module because now it's time to get serious. We're going to start learning Auto Layout in depth so you can go ahead and build truly unique user interfaces with confidence.

Understanding Constraints, Relations, and Priorities
Introduction
Welcome to the module, Understanding Constraints, Relationships, and Priorities. In the prior module, we discussed some of the ways we used to build user interfaces in iOS. And Auto Layout was introduced a few years ago, and it was really a game changer. But there was a challenge with it, and that was understanding Auto Layout itself. On a fundamental level, it was a different way to think about building user interfaces. So in this module, let's take this opportunity to lay the groundwork about Auto Layout and what it is and how it works. So the first thing we're going to do is look at the common constraints that you can build with Auto Layout. So this will give you a clear indication of the type of constraints you can lay out to build your user interfaces. Then we're going to take a look at the key components for constraints, things such as equality, priority, and relation. And it's really using these characteristics of a constraint which allow you to build a flexible and adaptive UI. Then we're going to discuss the various ways you can build constraints, which is one of the more challenging things about Auto Layout. There are many ways to do the same thing. And sometimes it makes sense to do it in Interface Builder. Other times it makes sense to do it in code. And so we're just going to quickly introduce a few of the methods that we can use. Then we're going to go into satisfying the constraints. And what do I mean by that? Well, I'm going to give you a mission, and that mission is to satisfy the constraints. And what you'll find is it's laying out enough constraints where the Auto Layout system can figure out an X and Y position and width and height for every view within your user interface. And now you're not doing this directly by setting those numbers directly, but you're doing it through a constraint-based system. And so I'm going to offer some tips to help you with that goal. Then we're going to dive into exactly what a constraint is. And we're going to look at it from the point of view of what it translates to--a linear equation. And we'll see how a constraint based on a linear equation can adjust views because that's what Auto Layout is. It's a series of linear equations, and you'll hear me say that again and again. And so by looking at it from that perspective, it will give you a clear indication of what the constraints are doing when you create a constraint. And then, finally, we're going to jump into Xcode and just do a small demo where we're going to build a single view application, lay out a couple of views, and just see how adjusting a constraint works. There's a lot of exciting material to cover, and it's going to lay the foundation for the rest of this course. So let's get going.

Constraints
So we want to introduce you to a lot of the constraints you're going to be working with when you use Auto Layout. And the foremost common ones you'll probably meet are the top, leading, trailing, and bottom. And when you set each of these constraints to a UI element and, say, attach it to the superview, like we have here, the UI element will be the exact distance of that constraint from the superview. And so as we shorten each constraint, that UI element will become larger and take up more space. And as we make them longer, that UI element will shrink. And, remember, it's all about relationships. And one of the most powerful things about the leading and trailing is when you have a language that goes right to left, these will swap. And so you see here if we have Arabic that the leading and the trailing flip around so that the characters are displayed in the correct order. But what if you don't want it to react to the localization? Well there are left and right constraints too. And so you see here we're using top, left, right, and bottom, but the length of those constraints is 0. So this UI element's right up next to each of its views. Now be careful when you're using left and right and leading and trailing because they cannot be intermixed. If you get a leading and a left constraint attached to each other, bad things will happen, and your program will blow up on you. And now we can see here, look, the UI stayed the same way when we switched back to English. And leading and trailing are where they're supposed to be, and the menu bar stayed to the left. Other constraints you have are width and height. You can specify the exact width and height of a constraint. You can also lay out constraints that say that something should be centered to X or centered to Y. And you can offset these to offset it from the center. And now the power of these constraints really comes in when you do combine them. So here we have center X and center Y, but we're specifying specifically that no matter what device this is on, we always want it to be this height and this width. There's also aspect ratio. So say you have an image, and you really always want to keep that same aspect ratio no matter what the width and height are, then you can do that. There's also baseline. And baseline is great because it can take the baseline of, say, UI labels, and you can attach these to the baseline. And what happens is even if the fonts get smaller and smaller and smaller, they're going to line up perfectly. And this really helps from a design aspect and makes your life a lot easier. So these are just the basics. And when you combine all of these, you'll see how flexible they really are. And we're going to be using all of these constraints over and over again in various ways.

The Constraint's Key Components
What are the base components that are important with a constraint? They're really easy. The first one is the constant. That's a number that just defines the distance. Is something 20 points away from this view? Or is the width 400? And that really simplifies things. And the next is relation. So is it equal? Is it greater than or equal? Or less than or equal? And this is really powerful because this gives you the ability to say, Well, I would like it to be 400 pixels wide, but as long as it's greater than 200, I'm okay. And it does offer a lot of flexibility, yet you might have some unique scenario for sizing or for laying out your views. And then the final key component is the priority. And this goes from 0 to 1000, 0 being the lowest priority and 1000 as being required. And this is really helpful when you want something to have a higher priority over something else. And we're going to see this in more advanced scenarios so we'll be covering priority later. But it is good to understand because it is a key component to how Auto Layout works where throughout this module, we really won't be messing with it. So now that we've gone over the base components, let's take a look at the way you would add constraints. And there are multiple ways to do it, so let's find out what they are.

Building Constraints
So let's go over the multiple ways that you can actually build constraints. These are listed in order of preference as Apple recommends them, and it is a good rule to follow. And so the first one we have is Interface Builder. With Interface Builder, you have the UI giving you a lot of feedback because Interface Builder's going to try to lay out the views and size the frames per how you lay out the constraints. And so you're getting a lot of information that you don't get using the other methods that we're going to mention. In addition with Interface Builder, you have this assistant editor where you can view multiple screen sizes all at once, and it's going to display what your UI would look like. And you're also given a lot of feedback if there are warnings or errors. You're going to get them right away instead of at runtime, which you would with the other methods as well. Probably the biggest downside to Interface Builder is if you need something very unique if you're using some sort of formula or you're going by percentages or something like that, then Interface Builder is not going to work for you because this really does rely on just regular numbers for constants and multipliers. You can't use fractions or anything like that. So the next one is the Visual Format Language. And this is a beast. If you ever see a runtime error, you might see something crazy, something crazy like this right here. I mean, what is this telling you? This is a special ASCII format that Apple uses, and you can create these strings to lay out and get back an array of constraints in code. It's really flexible, and it does take a little while to get used to the style. But it's definitely the second method that they recommend because it can generate multiple constraints at once. However, don't worry about this right now. We have a whole course that we're dedicating to the Visual Format Language. And you're going to learn to write it so you can generate multiple constraints in code. And you're also going to learn how to read it so you can properly debug in the console and through other methods. But for now, goodbye. Finally, we have the NSLayoutConstraint API, and this is the most powerful, yet it has the biggest downside because it's very hard to use if you're a beginner and you're not used to thinking in constraints. And it's very verbose. But we're going to see that later on in the module. So you can see here that you plenty of different methods to choose from, and we're going to be going over all of these and discussing their advantages and disadvantages along the way. And, again, don't forget the order of priority. Apple does recommend, and from my own experience, I recommend that you try starting with Interface Builder, and then move to the Visual Format Language, and then after that, if you really need to, switch to the NSLayoutConstraint API.

Your Mission: Satisfy the Constraints
So you're starting to learn about constraints and how Auto Layout works differently from methods in the past on iOS. And now I have a mission for you. And this is your mission: First, you want to finish the UI design before you start. This'll probably be one of the most helpful tips that I can give you where it's not a big deal if subtle changes occur within the design. However, if there are any drastic changes, you may find that you're going to have to tear down the majority of the constraints and just start over. It's just easier that way. So make sure your design is final and it's ready to go, and then start to lay out your constraints. And now when you start laying out the constraints, you want to make sure you satisfy the constraints. And this can't be stressed enough. But what do I mean by that, satisfy the constraints? Well, what we're talking about is really the X coordinate, Y coordinate, width, and height. And so you really want to just give it its position and its size. It doesn't matter what constraints you use to do that just as long as you lay out enough constraints to complete that job. And so with every object, think of this rectangular box, and you want to make sure that this box is its correct size. In this example, we just use top, leading, trailing, and bottom constraints. At this point, that gives Auto Layout enough information because it can say, Well, this is the size of my superview, and I want this image to be this far away from each edge of the superview, and so that's enough information to satisfy this. And just removing one of those constraints, suddenly it leaves Auto Layout confused. All of the sudden with this bottom constraint gone, it's like, Wait a minute, okay, so I know how far I should be from the top, leading, and trailing, but what about the bottom? And without the bottom information, it has no idea what the height of this imagery should be. And so it can't lay out the views properly. Of course, this isn't your only approach that you need to use. In this example, we have the center X, center Y, and width and height constraints. And so, again, this is giving its location. I want the center of that image in the center of my superview. And I want the image to be this exact width and height. See, again, we're providing the position and the size information, and that will satisfy the necessary constraints to build the UI. And now don't forget when you have multiple elements that this doesn't change. Now instead of satisfying just one Image View, we have three images that we need to satisfy, and the constraints need to be set up so that Auto Layout has enough information to lay out these three images. And so now you need to think about the X and Y coordinates of each one and the position they are from each other. And then at that point, Auto Layout will lay out the views appropriately. So, again, when I talk about satisfying the constraints, that's what I mean. And, finally, I want you to always think about the relationships. This will be more clear as we go through the demos what I mean by this. But just a quick overview, what I mean is think about your UI elements. And think if any of them are a core UI element that you can tie other constraints to. That way, when you modify one of the constraints on that key UI element, the rest can follow. And, again, I will show you in the demos what I mean by this, and I will say these same exact words--think about the relationships because it is crucial, and it does make your life a lot easier when working with Auto Layout. Now this isn't an all-encompassing guideline. These are just my opinions in what's really good to get you started and to really land on your feet when you're creating layouts with constraints in Auto Layout.

The Linear Equation
So we've gone over the different types of constraints, the various ways you can add them, the overall goals you're trying to achieve when laying out multiple constraints. But what is a constraint? And to answer this, essentially Auto Layout is a series of linear equations. It takes all of these equations and through some more advanced calculations using linear algebra, it's able to produce your user interface. So let's take a step back for a moment and just look at a constraint. And so what we're going to do in this video is just build a constraint, go step by step, and look at each component to see how it fits into the overall picture. And this'll give you a better sense of how every constraint just works in general. So here we have a Blue View. It's on the bottom of our screen. And what we're going to do is we're going to create a constraint that is tied to the top of that view, to the bottom of a Green View. We can set a multiplier and a constant on here, and we have our constraint. So, again, it's just a basic linear equation. And now you can see that if I increase the constant to 40, suddenly that constraint becomes longer, and it shrinks down the Blue View. If I were to double the multiplier and make it 2 and cut the constant in half, my constraint isn't going to change size at all because nothing underlying in this equation has changed. It's still the same formula. And now I can even knock the constant down to 5, and we'd have the constraint that we began with. So how does this linear equation directly translate into a constraint though? Up top, you have the NSLayoutConstraint, and we're going to go over this in depth later in the course. But this is how you would go and create a constraint in code. And so now let's break down the formula that we have below and place it into each parameter of this initializer. So our Blue View would go to the item because that's our first item. And then the Top attribute would be our first attribute on NSLayoutConstraint. And then the Equal sign is our relatedBy. And, again, you can have equal, greater than or equal, or less than or equal. And then the toItem, my second item, would be my Green View, and it would be the Bottom attribute. And then the multiplier and constant fall into place. And now if I tie this back to our previous example here, you could see that we have our iPhone back up. And I can go ahead and adjust the parameters on the multiplier and constant. And, again, our constraint increases in length. So it's very simple, and that's really what a constraint is, and that's what Auto Layout is, a series of linear equations. And that's how it's laying out the user interface. And so now that we've covered a lot of these topics, let's just jump into Xcode and just do a quick demo where we lay out a couple of views and just see live how we can change these constraints on the fly and update our user interface.

Constraint Demo
So we're in Xcode, and I just want to show you a small example of using Auto Layout. We're going to be using Interface Builder. Don't worry too much about the tools that I'm using. We're going to go into them in depth in the next module. So for now, I'm just going to create a single view application, and we'll just call this AutoLayoutSample. We'll use Swift. We won't even be coding anything. And create the project. So I'm just going to go to the Main. storyboard here, make some room, and we have our View Controller right here. And I'm going to lay out two UI views on the screen. So, I can copy and paste it. And we'll give them different colors. We'll follow the scheme from our slide and kind of do a green and a blue. And, in fact, to make it easier to understand everything, we'll name this Blue View. And this is just kind of a way to give the view an identifier within Interface Builder itself, which is always good to do if you're working with a lot of views. So now I've got my Green View and Blue View. And now I'm just going to lay out some constraints here. So I'm going to go to the pin menu with my Green View and do 0, 0, 0, add three constraints. And I want to give this a height of 300. And, again, this is satisfying the constraints, but don't worry too much about these details right now. We're going to be going through all of them a lot later. And then my blue one I can do a 0 leading, 0 trailing, and 0 bottom. Add those three constraints. And now I'm just going to Ctrl+drag from the blue to the green views and do vertical spacing. And what that did was it added this constraint between our two views. And just so you see here, I kind of quickly did Command+Option+equal sign to update this view to this yellow frame. But you can also do that by going to Update Frames in the Selected View or All Views In View Controller and hitting Update Frames. So, again, we're going to go over all of that in detail later. But for the sake of this example to keep you on track, that's how I did that, Command+Option+equal sign. So now I can select this constraint. And let's take a look. This is exactly what we saw on our slides in the prior video. We have Blue View. Top. We have the relation is Equal. And our second item is Green View. Bottom. And our constant at the moment is 266. And I can go ahead and change that to 100, and you see that our Blue View automatically updated. So we can change this to 50, and I could change the multiplier to 2, and you can see that the multiplier is having a much bigger impact on the view because of the way the linear equation works. And so this is really powerful. And the point of this example is to just show you how one of these constraints do work and how that linear equation is right here in front of you. And now, again, we really didn't concentrate on the priority, but the priority would indicate whether a linear equation had a higher priority over another one. That's one way to think about it. If I go ahead and run this in our simulator quick, and if I hold Command+right arrow key, you can see how in portrait and landscape modes that our views are adjusting and keeping their spacing. And now, again, don't worry too much about these details, but we're going to dive into this much later. But you can see how the Blue View is shrinking down, this 100-point distance is being maintained by the constraint, and our views are adjusting accordingly. And, again, our Green View doesn't change at all because of this height constraint. So it's really powerful. They're really easy to add. And once you get used to thinking about how constraints should work, you can really build really dynamic user interfaces that adapt to the devices really easily.

Summary
So we covered a lot of great material in this module. First, we went over the various constraints that you can actually use with Auto Layout. And then we dove into really the key components of a constraint with the constants, priorities, and relations. And with these three different key components, it offers you an incredible amount of flexibility when you're laying out your constraints. And then we talked about satisfying the constraints, the goal you're trying to achieve. You're using the constraints to do two things--give a view a position and a size. And then Auto Layout's going to do the calculations for you. So it is a different way of thinking about how you lay out your user interface, but once you get used to it, it makes a lot of sense, and it's really easy to comprehend. The first step, though, is just taking that leap into this different way of thinking. And with the goals that were laid out in this module, that will take you towards that goal. Then we took a look at a constraint's linear equation. That's what these are, these constraints are just a series of linear equations. And Auto Layout is using all of those equations to figure out your user interface. So it's really important to view it from that perspective. And we saw how that linear equation directly translates into the NSLayoutConstraint object itself. And then, finally, we brought it all together by just taking a moment to do a small demo. We laid out a few constraints between two views to see how it works. Once the constraints are working, you can adjust one, and you saw the user interface update immediately. And then on the phone, you saw as we were rotating between portrait and landscape mode, the user interface was being updated for you. So it's really powerful, and we've only begun to look under the hood of Auto Layout. There is so much more to see and do. So the first thing we're going to take a look at is in the next module, we're going to dive into Interface Builder and NSLayoutConstraint to see how we can build user interfaces in Interface Builder and in code. So see you there.

Diving into Interface Builder and NSLayoutConstraint
Introduction
Welcome to the module, Diving Into Interface Builder and NSLayoutConstraint. Now in the prior module, we went over the key elements of the constraints themselves and tried to look at a fundamental level what a constraint does, how it's constructed, and how it's even calculated. And now one of the challenging things with Auto Layout is there is more than one way to do everything. And you can use Interface Builder, NSLayoutConstraint, the visual format language, UIStackView, and new anchor APIs. And so it can be very confusing. So we're going to introduce them very slowly. And the first thing we're going to take a look at is Interface Builder and NSLayoutConstraint. So the first thing we're going to do is review the Interface Builder tools. And we're really going to concentrate on Interface Builder on the Auto Layout tools so you can see how you can quickly update constraints or update your frames and manage your constraints more easily. So there's a lot of good stuff to go over. And then we're going to go and build a splash screen using Interface Builder and the tools that we just reviewed. Then we're going to take a look at the NSLayoutConstraint API and see how constraints are built in code. And now this is a very verbose thing to do, but it's really good to know, to see it, and get used to it. And so we're going to go into our project and actually rebuild that same splash screen, but we're just going to do it in code instead so you can see how you can create the same interfaces with Auto Layout in Interface Builder and in code. Finally, we're going to take a more complex example, and we're going to build a menu screen in Interface Builder, and this will use a lot more constraints, but it will really show the flexibility and power of Auto Layout. So let's dive in.

Auto Layout Tools in Interface Builder
So we're in Interface Builder. And in this video, what we're going to do is go over some of the tools that you can use for Auto Layout and setting up constraints, seeing what views have constraints, and some of the various menus that are available to you. So we're here in our LaunchScreen. storyboard file, and this is the View Controller that will display when the app launches. And we're just going to go over a few things here and not do anything that involves our demo app. We're going to exit out of the menu screen here and hit Command+0. And the first thing I want to show you in our display area here are the four icons in the bottom right corner. Now the first one involves a Stack View, and the UIStackView was introduced in iOS 9. We're not going to go over it yet. I've explained why earlier. But just know that that menu is there for you. The next menu is the alignment menu, and this menu is really good for if you have various views and you want to quickly select all of them and align them to the leading edge or the trailing edge or the top edge, you can go select all of them, check the checkbox, and then add constraints. And then you have other ones here if you want to horizontally center, vertically center, baseline. This is really good when you have multiple views that you want to deal with at once. We will be using these as time goes on. The next menu is the pin menu, and this is really useful for adding your top, leading, trailing, and bottom, as well as width and height, and if you want two views to be equal widths or two views to be equal height, and you can even set an aspect ratio, which is really nice. And you also have an alignment option here, a quick access alignment option. And then at the bottom right corner here, the last icon we have is the resolve menu. And this is really good for when you want to take some quick actions after maybe you changed the constraint and you need to update all your views. This menu can actually be found in another place up here if we go to the top, and we go to Editor, and Resolve Auto Layout Issues. And you have the same menu here. And so you could do it for selected views, so if you have certain views selected, or you could update all views. And we'll show as a beginner how there's another method for dealing with this, which will make it much easier. To get started, though, let's go and add a simple view to our background. And just so we can really easily see what Auto Layout's doing with this view, we'll just give it a rather unique color. Now when I select it, and I go to the pin menu, I can add constraints. And you see here it automatically detects how far it is from each edge of its superview for you already. And so automatically it inputted these numbers here so you can quickly just click and add each of these. But for demonstration purposes, I'm actually going to just modify these on my own and set them all equal to 20. And you see here at the bottom, I can add four constraints. The constraints have been added, but they're yellow. And that's not normal. They would typically be blue, and they wouldn't have these numbers in here. And so it's trying to tell us something. And you can also tell this by the way the View hierarchy panel on the left side here has a yellow button. This View hierarchy's really great because it allows you to drill down and see what constraints are added to what view. And if you click on this button here, this can either be yellow or red, yellow saying, Well, the UI's going to lay out properly, but it's not going to look the way it does in Interface Builder. And a red one typically means that Interface Builder knows there's a problem with the constraints you've laid out, and you need to fix them before moving on or else your views are not going to lay out properly on the screen. And so if I click here, it's going to provide some information. Here you see it says Misplaced Views, and it gives you the expected dimensions. It's telling us what it actually sees, and so that makes a lot of sense. If we click on this, it actually gives us ways to resolve this issue. So I can update the frames, or I can update the constraints saying that is the size I want the view to be, and I would just rather change the constraints. I could do that. Or I could use Reset to suggested constraints, and Interface Builder will try to figure it out on its own. I typically don't like to use this. As you get more comfortable using Auto Layout, it just kind of gives you full control. When you use the suggested constraints, it might set it up in a way that you didn't intend, and then you have to go through and see what constraints were added. So I tend to avoid that option. And then, finally, Apply to all views in container. Sometimes you'll want to use this, sometimes you won't. So you have a lot of views here, and you just adjusted the size of one. Well, suddenly every view on the screen may need to be adjusted because that small constraint was modified. And so you'll have a bunch of useless data on this whole left side, and you can quickly check Apply to all views in container and quickly fix it, and it'll fix all of them and update it for you. So I'm going to go ahead here and fix misplacement. And you see that it updated our view. Now we could have done this with this other option. If I come and undo that, and I come to this resolve menu, I can do update frames. And, again, I have that option to update all the views in this View Controller if I know a lot of them were misaligned. So I'll click it, and now you can see that it's the size that we want it to be. Now I want to show you how to deal with errors and how that looks in the View hierarchy. But first I also want to show you a different way to add constraints in Interface Builder. So the pin menu and the alignment menu are not the only ways to add constraints. Another method is actually clicking on a view, and you can hold the Ctrl key down on your keyboard and drag with your mouse. And when I do that, you can see here that I'm given a pop-up option, and I have height and aspect ratio. And Interface Builder will try to figure out what constraints to provide you by how you control and drag. So if I hold the Ctrl key and make a horizontal line, I'm offered width and aspect ratio. If I go diagonal, it offers me width, height, and aspect ratio. And you see here at the bottom, it says Hold Shift to select multiple, Hold Option for alternates. So if I were to Ctrl+drag out of my view, now I'm offered different options because now it's trying to set up constraints that connect a view to its superview, and you can see here with the circle dot that we already have one set up, which we had set up in the pin menu. And I could come in here and add others if I want to just by holding down the Shift key and clicking. But I'm going to undo those. I don't want to add those. But one that I do want to add quick to show you something is I'm going to add a width constraint. You can see here that it adds it to its own internal view. And I'm going to select it, and I'm going to come up to the right side here, and you can see the item that's it's connected to, its relationship, and you can choose less than or equal or greater than or equal. You have the constant and the priority. And we'll get to the plus sign in a later course when we talk about trait collections and size classes. We also have the identifier, which is very useful when you need to debug your views because this will provide extra context within the debugger window if there are unsatisfiable constraints or there's something wrong with your constraints. Now while we're not going to go in depth into debugging constraints in this course, in that particular manner, it's still good to know because this identifier will allow you to label the constraints, make it easier for you to identify the constraints that might be causing the issue. So it's always good to use this especially when you have Auto Layout issues. And you have the placeholder, which we'll use later in the course as well, and it basically allows you to set up constraints that you want to satisfy Interface Builder but you don't want those constraints when the app actually runs. Finally, we have the install checkbox, and this just lets you enable and disable the constraint. If you were to uncheck the checkbox, it would simply detach the constraint but not delete it entirely. So if you wanted to re-add it, you could just select the checkbox. For now, I'm just going to change the constant of this width constraint to 20. You can see here that I caused an error. And all my constraints are red now. And that's because this view setup is impossible the way the size of the superview is and the way this subview is. If I go and click on this red box, Interface Builder's going to tell me that too. It's saying, Wait a minute. They're conflicting constraints. You can't do that. This is an issue. And if I click on this, it gives me the opportunity to actually select out of the conflicting ones to try to fix this issue. So I can come here and select the one we just had and delete constraints. And again now I have this warning, and I can fix the size issue. Another thing I wanted to show you if I select a view, actually I'll go to the View hierarchy and select it, and then jump over to the right here, I show the size inspector, I can see a list of the constraints that are set up on this view. If I click on the Edit button, I'm given quick access as if I had the constraint selected. So, again, here's my constant, and I can select the relation and the priority and the multiplier. I'm just going to leave these for right now. So there's a lot of information provided to you, and we're going to be using a lot of these controls throughout this course. Now I wanted to get you a sense of really what Interface Builder is providing you, the power that it's providing you because it's going to be really useful throughout this course. So let's start building our project, and we're going to start with the LaunchScreen.

Laying out the Splash Screen
So we're still in our LaunchScreen, and I'm going to go ahead and delete this view because what I really want is an Image View. So we can set up our logo, and we're going to set it up so it's adaptable to all the different devices, and this'll be a nice introduction into actually building out these UIs with Auto Layout. So I dragged an Image View on here, and I'm going to go and select my logo image. And now a nice little shortcut here that you can do for images, you can tell here it's kind of not the right size or the aspect ratio, and I can just come and hit Command+Option+equal sign, and it'll automatically adjust to the image's size. So it's just a nice little productivity tip. So I'm going to drag it to the center here. And there are a couple of things that I want right off the bat. We want it to be in the center, so I'm going to come here to my alignment constraints, and I'm going to click the Horizontal and Vertical in Container and add these too. And then I'm going to go to the pin menu, and I'm going to add the aspect ratio because no matter what size the screen is, I don't want it to get squished, so this is definitely a high priority. So we'll add that constraint as well. Already this is working out really well. But we're not quite done yet. I mean you can tell here just by looking at it that if the screen is too small that this is going to go off the sides. And we can see this here. I'm just going to collapse this quick and open up our assistant editor, collapse that as well. And go into preview. And you see here that it's just bumping right off the edges. We don't want that. What I want is I want it to be at least 20 points away from the leading and trailing edges of the screen. And so I could come in here, and I could just add it for all four actually. So we'll just do 20, 20, 20, and 20. Add four constraints. And you see this actually created an error because one of the issues we have is, well, it wants to be 20 away from the edge, but I'm also telling it to keep this aspect ratio. And I want it to be 20 from this edge, but I want it to keep the aspect ratio, so everything's just conflicting, which is an issue. So one thing that I can do is I can change the relation on these. I don't need it to equal 20. I just want it to be greater than or equal to 20. So I could select each one. In fact, I will open up this window here. It'll just be quicker to do it. I have my top, so I'll go here and do greater than or equal. And my leading, greater than or equal. And so you can see it's kind of already starting to fix itself. Do this greater than or equal. And then, finally, the bottom one. So it's 20 points from the bottom, and when I do greater than or equal, it'll pop to the center. Perfect! But what about our other devices? This assistant editor is really powerful, so let's check this out. I can check out the iPad. If I zoom out here, I can see that looks good. And if I rotate it to landscape, that looks good too. I can rotate the iPhone, the iPhone looks good. And I can even check out the new multitasking mode with the iPad. And, look, when it's one-third of the width, this logo is still laying out right. So, again, you've already seen the power here in just seven constraints. We add four for our top, leading, trailing, and bottom. We had two to center it in the X and center it in the Y. And then an aspect ratio. And with just those seven constraints, we're already able to adapt this image view to be flexible on any device that currently is out on the market and even future devices as well. I did notice one issue here. And so we got a little bit of a warning. And, again, it's just saying, Well, you added those constraints. It should be 20 away from each side. The frame isn't the right height, so, again, let's fix the misplacement. And now it looks right in Interface Builder as well. And this is why Auto Layout is so exciting. And we're going to start digging into even more complex views. But, again, it just has this nice way where once you get used to thinking about how Auto Layout works and how you can lay things out, then you're good to go.

NSLayoutConstraint API
So we're going to go over NSLayoutConstraint. Using NSLayoutConstraint, there are some advantages and disadvantages, and probably the biggest disadvantage is it's verbose. And you'll find this out as you start writing this API over and over and over again to add each single constraint. And this isn't even adding them to the view. This is just creating the one constraint. You kind of get the sense of why it can get a little bit annoying to work with. Another downside is it's difficult to master. As you get accustomed to using Auto Layout, it's going to get a lot easier to think through the UI layout and the constraints that are necessary to build that layout. However, when you're getting started using just NSLayoutConstraint in code, it can feel cumbersome, and you're missing a couple of constraints, but you can't figure out which ones are missing, and you're constantly restarting the app to try to figure it out. You don't get the same help that you do from Interface Builder, and you don't get the multiple constraints that are generated from the visual format language. However, the biggest upside to it is it's flexible. And you can't say enough about that. In Interface Builder, we have the aspect ratio given to us by Apple. However, that's technically impossible to do with the Interface Builder tools. You just can't create something like that. So when you kind of need that formula-based type of constraint, the NSLayoutConstraint API will come to your rescue because it is the most powerful, and if you have some sort of formula that you want to apply to the constant or the multiplier, you can do that with this API. And you can't do that with Interface Builder or the visual format language. So let's take a look at the NSLayoutConstraint and how you initialize the object, and you see here it's pretty verbose. There are a lot of parameters that you need to pass in, the first one being the item, that first view. And then the attribute for that item--is it top, leading, trailing? Is it centerX or centerY? And then you have the relatedBy, so is it equal? Is it greater than or less than? And then the toItem. And so as you see here, this is an optional because sometimes, for instance, with the width, you wouldn't add one. However, you can add a view, you can add the attribute for that view, and then you have the multiplier and constant. It offers a lot of flexibility, but it is a lot of typing. So let's take a quick look at the width constraint. So here you see we have our image rocketShip, and we're going to add it to our UIImageView. And then we're going to create our constraint, and so we have NSLayoutConstraint, and we have rocketShipView as our item. Our attribute is. Width. Our relatedBy is. Equal. And there is no second item, so we have that as nil. The attribute for that is NSLayoutAttribute. NotAnAttribute. And then the multiplier, and in this instance the constant, which is 200. And that'll give us a constraint for 200. And then we simply call rocketShipView. addConstraint and add our constraint. Well, what about something like the aspect ratio? How would you do that in code? I already told you if Apple hadn't provided it in Interface Builder, you would have to use NSLayoutConstraint to create this. And so, again, we have our imageView. We have our image, rocketShip, and added it to our imageView. And this time we grabbed the size, and we calculate the aspectRatio in code. And then with our constraint, we have item rocketShipView, and the attribute. Width, relatedBy. Equal. And then our second item is still the rocketShipView, and the attribute we're relating to, though, is. Height. And then the multiplier is where we use our aspectRatio, and the constant is 1. And this will give us that aspectRatio constraint that we add in Interface Builder. Like the width constraint before, we simply call rocketShipView. addConstraint and pass in the constraint. So it's a very simple API to work with. But, again, you can see the trouble where if you have a View Controller and you have 40, 50 constraints that you're adding to all these different views, it can get out of control very quickly, and it can be very challenging to debug. There are certainly use cases where you might want to do it. However, they will probably be few and far between. Again, the order of preference that Apple recommends is to try using Interface Builder. If you can't use Interface Builder, use the visual format language. If you can't use the visual format language, then use NSLayoutConstraint. So in the next video here, we're actually going to jump back to our logo because it was only seven constraints. And we're just going to show how you set that up in code.

Laying out the Splash Screen with NSLayoutConstraint
We're back in our Collaborate project, and we're going to quickly take a look at using the NSLayoutConstraint object instead of building constraints in Interface Builder. And so I'm in Main. storyboard, and I actually did a little bit of setup already. I have this Launch View Controller, and it's just an empty View Controller that I dragged from the right menu here. I disconnected our Main View Controller and created a root segue to this Launch View Controller. And this Launch View Controller has a custom class, LaunchViewController, and all we're going to do is we're just going to replicate the launch storyboard that we created in an earlier demo in code. So I'm going to go to the LaunchViewController, and one reason I'm not doing it in the launch storyboard is you actually can't. The LaunchScreen. storyboard can't use any kind of custom View Controller. So that's why I'm doing it in the Main. storyboard. So I have my LaunchViewController class here. All I did was in viewDidLoad, I went and created a UIImageView, and this is important. Whenever you create a UI object and generate it with the frame, you want to make sure that you set this logo. translatesAutoresizingMaskIntoConstraints equal to false. We're going to go in a later module into detail as to why you need to do this, but for now, just take my word for it. If you create any type of view in code, make sure you set this equal to false or else your constraints will break when you run the app. So I have my logo here, and I simply add it to my subview on my View Controller. And then I go ahead and make some constraints. Here you see the centerX and the centerY. And I pre-typed these out because, again, this is a very verbose API. And I didn't want to waste time generating these. But they're very simple. So item 1 is logo. The attribute's CenterX, and it's going to be Equal to the item self. view, which is our superview. It's going to match the CenterX with a multiplier of 1 and a constant of 0. I would like to point out the multiplier. For some reason, I always do this when I'm switching from Interface Builder to using the NSLayoutConstraint API. For some reason, I love to put a 0 in the multiplier. And anything times 0 is 0. So your views won't show up. I'm scratching my head. And I do it more often than I should. So I'd just like to point it out. If you lay out constraints and you see absolutely nothing, check to make sure you didn't do that too. So do the same with CenterY. You've already seen this in the slide with the aspectRatio, so I just grabbed the imageSize. And I used the logo in both item and toItem, and comparing it with the attributes. Width and. Height. And then the multiplier is simply that aspectRatio with a constant of 1. And then I create the top and leading. And you see here that really the main difference is that GreaterThanOrEqual. And so I do logo. addConstraint, and I add my aspectRatio to that. I want that constraint to apply strictly to the logo, so that's why I'm adding it to that view. This is a general rule that you want to follow. What are you going to add the constraints to? Well, it's that parent view. So if you are attaching to a superview, you're going to add the constraints to a superview. If your item and toItem is the same view or the same UI element, then you're going to add the constraint to that UI element. Finally, if you have two UI elements within the same parent view with a constraint tied to each of them, then you want to add that constraint to the superview of those two UI elements. It's a simple rule to follow. So I have logo. addConstraint(aspectRatio), and then I have self. view. addConstraints, and I'm passing in these four constraints. And so it's very simple. It's a nice convenience method where if you just have one constraint, you pass that in. And if you have an array of constraints, which would be typical, you have this convenient method as well. So I'm going to go ahead and run it here. And there you go! You can see the Collaborate that built in place of our menu. Now there is something that I'd actually like to point out here, which is a little odd. I actually found in Interface Builder, I actually added more constraints than I needed. I was able to satisfy this with just using the top and leading and, because of the aspectRatio, was able to build the UI for me the way I wanted it to. And so I can go here to LaunchScreen. storyboard, come in here, and delete the bottom layout constraint and my trailing one. And I still have the UI that I want. So now while it's nice in code, you could tell we lost something immediately. We don't have the assistant editor. We're really not getting that UI feedback like we do in Interface Builder. And so while the NSLayoutConstraint object has its place, and it is effective in solving various problems, it's still best to use Apple's recommended methods before you resort to that. I just wanted to show you a quick demo just so you could see how easy it is to use in terms of actually laying out the constraints. The challenging part is making sure you build all the constraints properly in code and get everything hooked up right without any sort of feedback until runtime.

Building the Menu Screen
So in this video, we're going to build our menu screen, and we want to make it adaptable to the iPhone and the iPad and have it work in both orientations, portrait and landscape modes. We're in our Main. storyboard here, and we're going to make some slight modifications. By default, when you create a new project with the master detail template, it's going to create a Master View Controller and a Detail View Controller for you. And since I always save, it'll automatically adapt that to the iPhone and iPad, so you have a Split View Controller on the iPad, and then you have a menu that you tap on an item, and on the iPhone, it'll take you to the detail screen. So instead of using the table view, which is provided by default, we're actually going to go ahead and delete this. And we'll delete the source file as well. And I'm actually going to lay out our own View Controller. And I'll create a new file. We'll call this Cocoa Touch Class, call it MainViewController, language Swift, Next. Put it in our Collaborate project. And the last thing I need to do is I actually need to set up the segues as they were before. So this is going to be View Controller segue. And, again, Ctrl+Drag to create segues. And this is going to be a show detail segue. Cool! So now we're set back up. One last thing--make this MainViewController. As you know from our example of the app we're going to build, we have this menu item. And there're about seven items that we have, and then an Image View on top of it. And so in order for this to work, depending on the screen size, we want to have this in a Scroll View. So I'll grab a Scroll View and drag that into our main area here. And I'm going to make it the full width, and I'm even going to go above the navigation bar here. And you can always get rid of this navigation bar if you click on the View Controller. Here it's inferring it. And we just want to get rid of it for the moment while we work just so it doesn't get in our way. Cool! So we want the Scroll View to take up the whole UI view screen. And so we've done this before. I'm going to hit Command+0 here to give us some more room. And I'm going to just use the pin menu like I always have. I select the Scroll View first, go to the pin menu. I'm actually not going to constrain to margins. One of the things we want here is we want to take up the full view, so I can just uncheck this box. And you see here now that I have 0s across the board. So let me go ahead and add my top, trailing, bottom, and leading, add four constraints. So now we have a Scroll View. And one thing I wanted to do first was change this background color to match the background color of our design document, so I'll just use the hex color here--23, 23, 23. We have the Image View that we want to add, and we're going to add this into our Scroll View. And in the images, PartnerInCrime, my little buddy here, we're going to use the trick that we did before. Remember, it's Command+Option and the equal sign to get the Image View to the proper size and aspect ratio that we want. What I'm going to do here now is lay out the rest of the UI element. So we'll start with a button. So we're back, and I just quickly laid out a bunch of buttons. And for the most part, they're kind of centered. You can tell the vertical spacing isn't exact. That's just so we can leverage Auto Layout to kind of fix that for us. But just for a pro tip, if you're curious, you could always select a UI element, and if you ever want to see the distance it is from another UI element, you could just hold down the option key. And wherever your mouse it, it will give you how far it is from everything. So you can see here from the superview, you have your values. If I go and hover over Profile, I could see that's 42 away from that. And that's 90 away from Collaborators. And this is really cool, so I can select this, 42. Logout is 236. It's just a nice little tip. So let's start by setting the constraints for Image View. Something we want to always keep in mind is---I want this 28 from the top. Something we always to keep in mind is think about the relationships. I'm going to say this over and over again because as you build these constraints out, if you kind of think about this ahead of time, you're almost anchoring these views to each other, so if you want them to be modified in some way, it'll actually be really easy to do with Auto Layout. But, again, it depends how you set up the constraints and how these will all interact with each other. And so the first thing I want is I want this to be 28 points from the top. So I'm going to Ctrl+Drag and select Top Space to Container. The other thing I want is I want this to be centered horizontally in the container. Cool! Now I want to worry about the Profile and the rest of the buttons. One more thing I wanted to add to the Image View is aspect ratio. There you go. So the first button I actually want that to be 28 away from my Image View, but then I want the rest of the buttons to be 20 away from each other. And so I have 35 there. If I just hit up seven times, one too many, I'm good to go, and I can Ctrl+Drag and say Vertical Spacing. A quick way to add multiples of these, because I want each one to be 20 away from each other, I can select Profile and then go ahead and select the rest of these. And what I'm going to do is I'm going to go in my pin menu, I'm going to put in the value of 20, and then you see here it says Add 7 Constraints. So I'm just going to go ahead and add seven constraints. And there you go. It started to set it up. And we have a lot of red here because this is something you'll just get used to when working with Auto Layout. You really need to satisfy all the constraints, and this could be one of the more frustrating parts as you start learning this because it just takes a little while to get used to. And you see here, I must have had the Image View selected, it created another constraint here for 20. So I have a conflicting constraint. I can delete that. And it's telling me here that this is 17 points away. It's just too far away, but we're not going to worry about that right now. Once we satisfy the constraints, we'll be able to just fix this issue, no problem. What I want to do now is I want to make sure that all these are centered to my Image View. And so I can go ahead and select these, and having selected my Image View first, I can then go to the pin menu, hit align. I can tell all the UI elements to center horizontally and add seven constraints. And now you can see here if I were to go to my Profile one, it actually added a constraint and tied it to the Image View. And if I go to Collaborators and select this one, it added a center constraint to the Image View. So now if I were to ever shift the Image View left or right, all these buttons should technically follow it. So, again, this is a very powerful idea, and this is really trying to leverage Auto Layout to its best ability. So our constraints are still messed up, and one thing that I do know I'm missing is the Logout. We don't have a correct value to the bottom of the View Controller. And so it's not able to determine the height of each UI element here because we haven't satisfied all the constraints yet. So I'm going to go ahead, and actually I'm going to use the pin menu because I want to have it be a specific value. You see right here that it's 51 away, but I want it to be 28. And so I'm going to add one more constraint. So let's use View hierarchy to see what else we need to do. This is really good especially as you're getting used to working with Auto Layout. Let the View hierarchy guide you, and if you aren't sure what gaps are missing to satisfy all the constraints, use it as a reference and try to get rid of any errors or ambiguity that might exist. So it's saying the Scroll View has ambiguous scrollable content from the width side. And that's because it doesn't know how long each of these buttons are or this Image View is. And so it's leaving it kind of confused. And so one thing we can do is we can actually go here to our Profile, we can make these, let's make it 50 points away from each edge, leading and trailing. And we'll add these two constraints. So now the width is gone, but what about the rest of these though? Think about the relationships. Whenever I adjust the Profile, I want the other buttons to adjust. If I were to do a leading and trailing for each of these on their own, then when I go and change this, I would have to change each one. However, so there are multiple ways I can do this. Now, I have the option of doing equal widths to Profile, or I can tie their own leading and trailing and connect them to Profile. So I'm going to use equal widths here because I think that'll be easier. So if I go and go to the pin menu and now do Equal Widths, Add 6 Constraints, it's now set all of these to be the equal width of Profile. And now if I go here, and I say Update all frames in our Main View Controller, we're good to go. And there's just some slight adjustments that need to be made. Sometimes this will happen where you have to adjust it multiple times because something shifts when it adjusts, and don't be surprised if you maybe need to do it two or three times instead of just once. And there you go. We have our layout now. Everything's satisfied. It's not showing any Auto Layout issues. So let's go ahead and run this. I have an iPhone 5S simulator here. And see in horizontal mode already, I can see that it worked properly. And something that automatically happened is we have our navigation bar here, and the Scroll View and anything that uses a Scroll View has extra content added onto it automatically by iOS. What this allows is that you get that nice transparent look under the navigation bar, which is part of the redesign with iOS 7. When you're working in Interface Builder, that's when we want to bring it to the very top because iOS is going to add the extra pixels underneath the nav bar and adjust accordingly. And you can see this in vertical mode. So it looks pretty good. And everything is as far away as it should be. So let's take a look quick at an iPad version. So the quality here doesn't look very good because I had to zoom this simulator. But if we were to bring out our Main View Controller, look at that. It looks good. And if I turn it sideways, it automatically appears in landscape mode, and there's no need for it to scroll because it's not going to extend beyond the bounds of the view that's showing right now. We were able to leverage Auto Layout in multiple ways. So this is really nice. And remember what I was talking about when I said, you know, if we think about our relationships, suddenly if I want to go ahead and modify how far everything is from each other, I can go and change this to 30. So if I go and modify the Image View and change that to 30, you can see that all of the sudden, all the buttons shift underneath. And with my Profile, if I come to this leading constraint and I select and make this 100 instead, you can see that all of the buttons automatically adjusted underneath too because they're all tied together to this Profile. So think about that. Try to find that parent UI element that you want the others to react to and tie your constraints to them that way. It will really simplify things if you ever need to shift the UI around. Of course if you ever have real drastic changes in your user interface, this method won't work. It's really more for simple subtle changes. So congratulations on completing your first complex view using Auto Layout constraints.

Summary
So we're at the end of the module, and we covered a lot of material. First, we dove into the Interface Builder tools and reviewed a lot of the tools that we can leverage to make working with Auto Layout a lot easier. We saw how to build constraints, update our constraints or update our frames depending on our needs, how to clear the constraints completely. We also took a look at the NSLayoutConstraint object that's provided in the UI Kit, and the API, very verbose API, that allows us to add constraints in code. We then built the same splash screen using these two methods. We built it in Interface Builder, and then we went ahead and did it in code, and we were able to build the same exact user interface with both methods. And you could see that we basically were able to add the constraints one for one between Interface Builder and NSLayoutConstraint. We also looked at the storyboard assistant editor, which is really useful to quickly view your user interfaces directly in Interface Builder. And this allows you to add an iPhone and an iPad, so as you're building these constraints out, you can see the impact it has on the different screen sizes. We then went and we built an adaptive menu screen that worked on the iPhone and the iPad that was built into a Scroll view. And here as we discussed the prior module, I tried to point out how you should think about the relationships of your constraints because if you think about them and you lay them out in the right way, you can update your user interface pretty easily. And you don't have to update ten constraints because you want to increase the padding on the left side or move things down from the top about 20 points. It may only take one or two constraints max to do that, again, as long as you tie your UI elements together in the appropriate way that makes sense to your user interface. So, again, there's a lot to be said about doing a little planning ahead and thinking about the constraints that you're laying out. Now we did mention that there are so many more ways to add and work with constraints besides Interface Builder and NSLayoutConstraint, but it's important to have a grasp on what Auto Layout is doing underneath the hood. When is the process running? When are the constraints being calculated? When are the frame sizes being set? And do we have any way to control that? And, also, what about the views themselves? Why are the top and bottom, leading and trailing constraints where they are on views? And over the next few modules, we are going to take a look at the rendering pipeline so we have a solid understanding of Auto Layout and how we can control that to our own needs. So see you in the next module.

Controlling Auto Layout's Rendering Pipeline
Introduction
Welcome to the module, Controlling Auto Layout's Rendering Pipeline. One of the most confusing things with Auto Layout is how exactly is it setting up the constraints? How do you know when it's aligning to a baseline? And what do the leading and trailing really mean? And do you have any control over it? And so in the next two modules, we're going to be going into this in great detail because the answer is Yes, you do have full control over it, and you can tell Auto Layout how you want the constraints to set up on your view and how you want things to align and where the baseline should be if one's even necessary. So we're first going to go over just the rendering pipeline itself. And we're going to go into this in great detail. We're also going to see how you can actually step into each phase of this rendering pipeline, which will be really helpful because this is where you can update constraints, or perhaps you do need to do some manual frame calculation, and it's going to be in one of these steps that you can hook in and do that for your views, for your custom views. We'll also go into the UI View Controller and Auto Layout, and at what point in the process of the View Controller's cycle, lifecycle, does it lay out the subviews, which just is always an important step to know so you know when and how you can prepare to set up any views that you might want to within the View Controller, within UI View Controller itself. We're also going to talk about the autoresizing mask, which is kind of the Legacy layout system that used to be used on OS X and iOS. And you can still use this system in conjunction with Auto Layout. And in the last module, we had used that property, translateAutoresizingMasksIntoConstraints, and I didn't give it any explanation. Well now that we're talking about how Auto Layout works under the hood, this'll be a great time to go over that. And then throughout this module, we're going to build a small demo application which doesn't involve our Collaborate demo project, and we're just going to build a simple Venn Diagram. And with this Venn Diagram demo, we're going to accomplish a few goals. One, we'll get a good chance to review a lot of the tools that we went over in Interface Builder and just how to build and interact with constraints. Two, we're going to use this demo to go into the rendering pipeline in great detail, and you're going to get a chance to see how updateConstraints and layoutSubviews and all these steps work and how you can use them to control Auto Layout. And then we're going to go over some random topics such as IBOutlets NSLayoutConstraint, which is something that we haven't done yet in Interface Builder. By the end of this module, you will have a great understanding of the rendering pipeline that Auto Layout uses. So let's get going.

The Rendering Pipeline
So let's take a look at the rendering pipeline and see how Auto Layout is going to lay out our views. There are three important steps that are involved with this, the first one being updateConstraints. And this is where the views are analyzed and measured based on their constraints. The next step is layoutSubviews. And so here the actual size of the frames and the positions are set in the View hierarchy. And, last, the view is displayed to the user. The views are rendered to the screen so the user can see them. So let's go through each of these one by one. So updateConstraints works from the bottom up. And here you can see I have a View hierarchy here with a parent view, which has two subviews, and then they have their own children. And so it's this A, B, C, and D view that are going to be analyzed first in updateConstraints. And then subviews 1 and 2 will be. And then, finally, the parent view. And this makes a lot of sense if you think about it because it needs to go from the bottom up so it can analyze those children, see how much room it needs for them, and now give the system a better idea of what size the parent view should be. And then once that's complete, it's going to go into laying out the subviews. So, again, we have the same View hierarchy here, but it's going to go from the top and work its way down to the bottom. And so you see here we have the phone on the left, and it lays out the parent view. And then it lays out subview 1 and subview 2, and then their children views. And this gives you a better sense of---so now we have those frames, and we have the positions of those frames and their sizes. Once those are laid out, finally Display is called, and the views are then rendered to the screen. And that's it! It might seem like an oversimplification, but that's really all that's happening under the hood. And, of course, there're a lot of calculations being done under the hood, but it's these three simple steps that are generating your layout for you. And one of the best things about this is we have the ability to hook into each of these steps. So let's take a look at how to do that and when it's appropriate to do it.

Hooking into the Pipeline
So we discussed the three stages that Auto Layout's going to go through when using the rendering pipeline. And the important thing about these three steps is you can hook into them by overriding certain methods within UI View, and there are even calls you can make to make sure that those methods get called on your custom view. So let's start with the first one--updateConstraints. So in UI View, you can update constraints. And what should you do in this method? Well, at this point in the rendering stage, the views have not been laid out yet, and Auto Layout is going to figure out working from the bottom up what the view sizes should be. And so at this point, it's measuring all the views and all the constraints in the views so it can do a proper calculation at the end. So you override updateConstraints, and the important key here is to call super. updateConstraints after you have made any changes to your constraints that you need to make within the method because, again, remember, it's working from the bottom up. So at this point, you want to make sure that as a subview you make your changes and then call super. And so that's exactly what goes in this method--constraints for your custom view. And you may not always need to do this. This is going to be something that has to be flexible. Perhaps a user takes a certain action or the UI is going to change in a certain way where perhaps you need to change the height constraint on something or you want to change the distance between two leading points on two separate views within your custom view. This is where you would do that. And if you want to get the rendering pipeline to call this method, then you can simply call self. setNeedsUpdateConstraints, And it will mark it for the next rendering pass. Of course, if you're outside of the view, you would call view. setNeedsUpdateConstraints. And a couple of things to note about updateConstraints is that, one, you can modify constraints outside of this method. There will be plenty of times when it might just be simpler to update a constraint in your View Controller because a user clicked a button, and you want to adjust the UI in some way. This is really a useful method for when you do need to change multiple constraints within your subviews because it can localize it all to this one area, and it'll be easier to read and more maintainable. And anyone that understands Auto Layout can go and look for this method expecting to see that you have changed constraints. And the next stage of the process is Auto Layout's going to go and lay out all of the subviews. At this point, it knows the frame sizes and so it can start laying out those frames properly. And now, again, this stage goes from the top and works its way down to the lowest views. So in this instance, you would override layoutSubviews in your UI View. And unlike updateConstraints where you waited to the end to call super, you want to make sure you call super. layoutSubviews first because, again, we're working from the top down. And now what would you do in this method? Well, this is your chance to set any frames that you want to set manually. Perhaps you need to resize something. Perhaps you know, Well, based on certain circumstances, I definitely want this frame to not be impacted by Auto Layout. And you want to adjust it accordingly. You can do that in this method. So you never want to be adjusting constraints in this method because at this point, it's too late. That's what updateConstraints is for because by this point of the stage, we already have our frames. And definitely do not call self. setNeedsUpdateConstraintsWithinThisMethod either because you're in the middle of the layout process, and then you're basically flagging it to restart the whole layout process again. And so it can just keep calling itself over and over as self. setNeedsUpdateConstraints keeps getting called. So, again, these are very powerful methods that you can hook into, but you must be careful in how you use them. They're supposed to be used for specific purposes. And to call into this process, you would call self. setNeedsLayout. And if you're outside of the view, perhaps you're in the View Controller, you would call view. setNeedsLayout. And then, finally, the final stage is draw rect. And this has been around since the beginning. It's always been a part of UI View. But, again, if you have any custom rendering, at this point in the stage, you know that your constraints have been updated, the frame sizes have been set, and so if there's some custom drawing you wanted to do, this would be your opportunity to do it. So these are very powerful mechanisms. So you have updateConstraints, layoutSubviews, and draw rect. And each one of them is used specifically for something. So make sure you use them appropriately. And if you do, you'll be able to do anything you want to with Auto Layout. Finally, the last thing we're going to talk about is how to force Auto Layout to run through this process. And so we discussed setNeedsUpdateConstraints and setNeedsLayout. However, there are other calls that you can make. So, for instance, if we want Auto Layout to update our constraints because we want to see what those new constraints are because we think there was some sort of modification on them, we can call updateConstraintsIfNeeded, and that will force the process. Something worth noting, though, is if you call setNeedsLayout, it is going to call updateConstraintsIfNeeded. So it's really not necessary to call it. There'll probably be special circumstances where you find the need to call it. And the other matching method is after setNeedsLayout, you could call layoutIfNeeded. And this is going to run the whole process. It's going to update your constraints, and then it's going to call layoutSubviews and lay out the new frames for your views. And the time you really want to call this is if you need to know the frames immediately. Perhaps you have a large amount of text coming in, and you need to adjust the textbox accordingly. That might be one of those instances where you would want to call layoutIfNeeded so you could get that frame size right away. But just remember, it doesn't always need to be called. Just by marking the setNeedsUpdateConstraints or setNeedsLayout, it's going to take care of it for you. And, again, the most common pattern you'll probably see across the internet is the setNeedsLayout and layoutIfNeeded. It is going to take care of having Auto Layout run through the layout process. And now that we have a better understanding of how we can hook into this system, we're now going to go into Xcode and start building a Venn Diagram demo so we can see in code how we can control the rendering pipeline to suit our needs.

Setting up the Venn Diagram
So we're in a new Xcode project, and we're just going to make a small app, and it's going to be a Venn Diagram. And with this Venn Diagram, we're going to show the steps that Auto Layout takes to lay out all the views and how you have full control over it. And now this is a really small example. And so the Venn Diagram will have a few buttons as well where we can say to make the left circle bigger than the right, make the Venn Diagram balance so they're both equal sizes, and then a right button to make the right circle bigger and the left circle smaller. And we're going to do all of this using Auto Layout. So I have an empty View Controller here on my storyboard, and this inherits from View Controller. Now I've already set up some code, and what we're going to do is we'll build the view using Auto Layout and hook everything up so you get a good grasp of everything that's going on with the rendering pipeline. So first I'm going to go into the ViewController. Now in the ViewController, we have a vennDiagram, which is our UIView and inherits from UIView. And then we have three actions--leftTapped, balancedTapped, and rightTapped--which will be three buttons that we put on our ViewController. And all this does is change the property weight in vennDiagram. Now going into vennDiagram, it's a very simple class. Up here you can see I created a small enumeration for a left, balanced, and right. Let's make a little more room here. And vennDiagram inherits from UIView. And you see here I already created six IBOutlets so we can connect our constraints from Interface Builder to our view. And now this is something we haven't done yet. And this is really cool! We can connect our constraints in Interface Builder the same way you would with a UI button, UI label, or any other view or UI control. So we have six here. We have three for the left circle, the top, leading, and bottom constraints, and then we have three for the right circle, the top, trailing, and bottom. And then we have a weight property. And it defaults to Balanced. And when we set this property, we're calling self. setNeedsUpdateConstraints. We are telling Auto Layout, Well, something changed on this view, and the constraints need to be recalculated. If we go to the overridden updateConstraints, we see exactly this. Now take note that super is at the bottom. UpdateConstraints is taking a bottom up approach in terms of calculating the constraints. And in updateConstraints, we just have a switch statement on our weight property, and if it's left, we make the constants for our left circle equal to 20, so they're 20 points away from the edges of the superview. And we set the right circle constraints to 40, so they're going to be further away from the edges of the superview. In balanced, both the right and the left are set to 20, so they're both an equal distance from the parent view. And then in right, we do the opposite. The left circle is 40 points away, and the right circle is 20 points away, so the right circle will be bigger. And then we call super. updateConstraints. So our next views up in the View hierarchy can have their constraints updated as well. And now we also have a CircleView, and the CircleView is a very simple class as well, which inherits from UIView. And so we have this IBDesignable here so we can actually see the changes live in Interface Builder. And then I have an IBInspectable property here, which just allows us to change the fillColor. And you see here that I'm calling self. layoutSubviews, self. layoutIfNeeded. And you'll see why in a moment in layoutSubviews. And so I overrode both the init methods just to set a standard fillColor and backgroundColor. And I have overridden the layerClass property because we want the backing layer of our UIView to be a CAShapeLayer instead of the standard CALayer, core animation layer, which is typically set by default. And we have a convenience property here for our shapeLayer, and it has strongly cast the layer property to a CAShapeLayer. And then we overrode layoutSubviews. And here we have---we're calling super. layoutSubviews first because, remember, at this point of the layout phase, we're working from the top to the bottom, so we want to make sure we call that first. And then I create a bezierPath ovalInRect to give us a circle, and we're passing in this view's bounds because in this phase of the Auto Layout cycle after super. layoutSubviews has run, we now know the size of what this view's bounds and frame are going to be so we can use it here. And then I simply just set the fillColor and the path of our shapeLayer so it renders properly so the circle is the correct size after the constraints have been calculated. So now that we've reviewed these classes, let's start building the view and set everything up with Auto Layout.

Laying out the Venn Diagram
So we just reviewed the code for our Venn Diagram project. We're now in Interface Builder, and we're going to start laying out our user interface. So I'll first go here, type in View to filter. And I'm just going to grab a blank view here. And I'm going to call this view VennDiagram. Now I'm going to drag two more views into this. I'll create one first and call it CircleView. And we want it to be square at least just to make things easier as we lay out our constraints. And I want to change the background color set to white color. We want to make that clear. And the fill color, our IBInspectable property, I want to change that as well, so I'll change it to this semi-transparent green here that I already had set up. And now I can just click the Option key, hold down the Option key, and drag this to make a copy so it's a similar size. And now I can set this to, let's set it to this blue color here that's semi-transparent. So you see we have the start of our Venn Diagram. Now let's start to lay out the constraints for this. So we'll first start with the Venn Diagram pieces, and I'll start with the left one. So let's select that. And now we said by default that we wanted the top, the leading, and the trailing to be 20 points away. And so I'll add those three constraints. And now for the right one, we wanted the top, we wanted the trailing, and the bottom to be 20 points away. I want these overlapping a bit so I can go ahead and connect these. And we'll do a horizontal spacing. And you can see that this gave us a negative number. And let's go ahead and make that an even -40. I don't want to change our priority. Cool! So we have lots of red, and this is something you will get used to when working with Auto Layout because we still haven't satisfied all the constraints, and we're still working here. So don't get nervous. We just need to keep plugging away until everything adds up. So now that we've satisfied the top, leading, trailing, and bottom of both these Venn Diagram circles, let's now look at the VennDiagram view itself and take care of it within its parent view. So something we want to do here is I want to give it an internal width of 240. And this is just so it fits within the width of the phone frame. We can make this greater than or equal to just so it has the ability to grow depending on the circumstances. And now I can go ahead and---in fact I'll do it through this menu here and create top, leading, and bottom, and I'm going to do 20, 20, and 20. 20 is the magic number for this lesson. I'm going to go ahead and add these three constraints. And now something I do want to take care of here is I actually want this leading to be greater than or equal, and I want this trailing to be greater than or equal. And one other thing I'm going to add is I'm actually going to add another leading constraint here. And I'm going to make it equal to 20. And this is actually satisfying the constraints because I'm using that greater than or equal to, it still isn't sure what it should be doing because we're saying, Well, be greater than or equal to 240 points, be greater than or equal to 20 points away from the leading and trailing of our superview, and so I'm going to give it this concrete constraint. But one thing I am going to do is I want to lower the priority of it. And when you're dealing with priorities, again, kind of the standard range is 250, 750, and 1000. And 250 is pretty much for content hugging. 750 is for the compression resistance priorities, which we're going to go into content hugging and compression resistance later in the rendering pipeline modules. And 1000 is default, it's required. And so every constraint we make in Interface Builder defaults to 1000. And so we're just going to lower this a little bit. So it can say, Okay, well, worth case scenario, I will be 20 points away from the leading. And, finally, we'll just go to the bottom just to satisfy this and make it happy. And it says we're still missing something here. So let's take a look. So it's saying there's some ambiguity here. One thing I am missing is internally on this, I did make a mistake here. We want aspect ratio, and we want to keep this one to one. And now that helped fix the constraints. And why did that happen? It had trouble detecting. We gave it X and Y coordinates with the top, leading, trailing, and bottom for both our left and right circles, but it was a little confused about kind of what the width and height should be. And so by giving it that one to one ratio because we always want it to look like a circle or have the shape of a circle, it helped satisfy that width and height. Remember when we talked about satisfying the constraints, we'd need the position, X and Y, and then the size as well, width and height. And so that helped. And now you can see everything is yellow here, which basically means we just need to go ahead and update our frames. So if I come to this and say All Views in View Controller, Update Frames. And now we have our Venn Diagram here working a bit. And, finally, the last thing I want to do, which I did miss, is I want this to be centered. And so I'm going to say center horizontally in our container. And there you go. So now it updated. Now we're not quite done yet. The next thing we want to do is our buttons. And so I did add this bottom constraint to the bottom of our superview just to satisfy everything and make sure everything is good. But I'm now going to delete that. And I'm going to type in Button here. And now I'm going to add three buttons. And now we want the buttons to be equal widths along the bottom. And so this is really easy to do in Auto Layout. So I'm first going to go here, and I'm going to ignore the top constraint for the moment, which we will tie to the Venn Diagram. And the first thing I'll do is our leading, trailing, and bottom, and we'll do 8, 8, and 8. In fact, let's make this 0 and 0 because I want them up against the edges. And I want it all the way to the edge. That's why I'm getting rid of the constraint to origin. And I want the width---or I want the height to be 44 points. So I'm just going to set a standard height for this. Add those four constraints. And so you see here the frame should be all the way butted up against this edge. And we're not done yet. So the next thing I want to do is I'm going to come here, and I'm going to align this to the top and the bottom so that both the buttons align properly. And then for here, I can go ahead and add a leading and a trailing and add these two constraints. And I'm going to do the same with the second and third ones. So I'm going to do top and bottom, holding down the Shift key to add multiple constraints. And then I'm also going to make this leading and trailing 0 and 0 and add those two constraints. So it still doesn't look right, and the next piece that we're missing is we want to set them so they're equal widths. So the constraints we've added we've just said, Well, make sure they're aligned to the top and bottom and that the leading and trailing are 0 so they're butting up right next to each other. Yet it's still not enough to get it working properly. So if we go ahead and do equal widths, and I go ahead and select this, and we're going to set the second and third buttons to be equal widths. And, finally, we're going to tie the vertical spacing between our first button and the Venn Diagram. And so we're going to do the vertical spacing between the left button and our Venn Diagram. And we'll make sure that it's greater than or equal to 8. And now it's complaining about an issue, and it sees conflicting constraints here. So it looks like we had two constraints added here, and we have Button. leading = leading and Button. leading = leadingMargin. And the margin one is the one we don't want. So I'm going to go ahead and delete that. And now if we go ahead and update our frames, it looks like something's still not right here. And so these are butting up right next to each other. So what's going on? And it looks like our trailing constraint to our superview just doesn't exist at the moment. And so let's go ahead and do Trailing Space to Container View. If we go ahead and set this to 0, there you go! They all adjusted. But you still see here that it's trying to tie it to the margin. So you can just come up here and say uncheck Relative to margin. And now the buttons are going all the way across the bottom. So here I'll do Left, Balanced, and Right, just name all three of our buttons. And let's run this quick just to make sure everything is good to go. That's right, we need to connect all of our IBOutlets. My mistake. So, let's again make more room, and let's go to our inspector over here for our connections. And I'm going to go ahead and select the View Controller. Now, remember, we had the Venn Diagram outlet, so I can go ahead and connect that. And then we had our three actions here for our buttons. And so let's go to leftTapped and to Touch Up Inside, balanceTapped, Touch Up Inside, and, finally, rightTapped, Touch Up Inside. Great! And then in our Venn Diagram, we had our six outlets for our constraints. And so we can just open this up here since they were in the Venn Diagram, open up our inspector, and you can see here our top, bottom, and leading for both of our circles. So we can go ahead and start connecting these. So we have the Left Circle Bottom. And a nice feature too is as you connect it, it actually changes its name so it makes it easier to read. So let's go ahead and expand that out so we can fully see them. And now our Leading Constraint, and our Left Top. Now let's do the Right Bottom. Select the Venn Diagram, the Right Top. And, finally, the Right Trailing. Great! Now we have all of our IBOutlets set up. And our app is ready to run. So you see here we have our Venn Diagram. I can go ahead and rotate it here. It got really big. Let's zoom this out with the simulator, you can do Command+5 to make it smaller. And now if I click the Left button here, you can see that the constraints have updated, and the left circle is now bigger than the right. If I click Balanced, they're equal sizes. And if I click the Right one, the right one is now bigger than the left. So this is awesome! We built the really powerful user interface. Now let's take a closer look at what the rendering pipeline is doing, and let's see what we laid out here with our constraint-based system.

Breaking Down the Venn Diagram
Now that we've built the layout, let's review the rendering pipeline and how we were able to control it with this Venn Diagram demo. So if I actually go to my Venn Diagram, and I can set a breakpoint here, and then I can go to my layoutSubviews, set a point there, and go back to the simulator. And if I hit Balanced, again, we had our action method, which is setting the weight of our VennDiagram view. And once that weight is set, setNeedsUpdateConstraints is called internally on our VennDiagram view. And so updateConstraints gets called, and it's now recalculating the constraints based on the new information. And then once it's done doing that, it goes ahead and works from the top down with layoutSubviews. And it's able to use the frame information to set up and resize our circle properly. And so once that's done, we have two equal circles. Now there's something I'd like to point out here. You may have noticed that I actually did some drawing in layoutSubviews. When we discussed kind of the stages that you go through with Auto Layout, you have updateConstraints, you have layoutSubviews, and you have the drawing, why would I do drawing here? And you could argue that I was being a little sneaky about it because the layoutSubviews is a very shady method because you're in the middle of the layout cycle, and all the frames may not be calculated at this point. However, setting this up I knew that the CircleView was my bottom view, and once super. layoutSubviews was called on my CircleView, I had all the frame information that I needed to do what I wanted to do, which allowed me to do the drawing in layoutSubviews. Now say layoutSubviews had its own children views, perhaps even smaller circles making up certain categories within the Venn Diagram, and at this point, I may not have been able to do this because perhaps I needed to wait to find out what all those children frame sizes would be before I could do any drawing. And so at this point, layoutSubviews would have been an inappropriate place for me to do any type of rendering and drawing. This is really cool, though, because once you have a firm understanding of this rendering pipeline, you can kind of make these decisions and just say, Well, I know there's nothing really after this point in terms of the layout process, so I can go ahead and do what I need to here. So with this example, we've been able to see a lot of how Auto Layout just works internally. So we were able to create these views, which by the way Venn Diagram had absolutely no reference to CircleView. The only thing Venn Diagram had any reference to were the constraints. It had no knowledge of the actual circle, which is pretty cool. And another thing worth pointing out is, sure, I used updateConstraints in this example here, but, again, you don't have to change your constraints in updateConstraints. Perhaps it might make more sense to change the constraints in a View Controller or somewhere else, and then you just need to make sure that you call setNeedsUpdateConstraints so it can go ahead and recalculate everything properly. Once you understand the process, you're the one that gets to make the decisions on how you're going to make it work. So now that we've discussed the rendering pipeline, and we've seen updateConstraints and layoutSubviews, let's take a look at one last piece in this Venn Diagram demo, and that's how we can use the View Controller before the views are laid out by the Auto Layout system.

UIViewController: Layout Subviews
So the View Controller methods are very simple. And so you're used to using UIViewController and maybe overriding viewDidLoad, viewWillAppear, viewDidAppear based on your needs. And there're two other methods provided to you to handle when the View Controller's view's bounds are going to change. And that's viewWillLayoutSubviews and viewDidLayoutSubviews. And these are great methods to use because whenever the View Controller's view's bounds are going to change, these two methods are going to be called before and after respectively, so this is your chance to do any pre- and post-work before Auto Layout runs and lays out the View hierarchy again. So they're very easy to use and very easy to override. So let's jump back into our Venn Diagram demo quickly and check them out. So we're back in our Venn Diagram demo, and we're just going to quickly take a look at the View Controller and the lifecycle methods. We quickly went over this in the slides, and you have viewWillLayoutSubviews and viewDidLayoutSubviews. And now this will be set initially when your View Controller first wakes up. However, something to note here is that it will be called any time it detects that a View Controller's view's bounds are going to be changed and laid out. So here I'm actually initializing our Venn Diagram to be weighted to the left in viewDidLoad. And this isn't something I would want to do in viewWillLayoutSubviews because then every time the view changes or goes to lay itself out, then this is going to set it to left. And, really, the user won't see anything happen. So let me quickly run the app here. And you can see here that the Venn Diagram has started with the balance to the left and the weight to the left. And you can see in our log here that Will layout subviews was actually called twice. And if I click a button, Will layout subviews is called again, and if I click it again. And now if I hold the Command key down and hit the right arrow on the simulator to rotate the device, viewWillLayoutSubviews was called again. If I keep rotating, it keeps getting called. So it's a very powerful mechanism, and it's just a good thing to know because you do have your viewDidLoad, viewWillAppear, viewDidAppear, and the viewWillLayoutSubviews is kind of the special case because, sure, it gets called on that initial lifecycle call, but, again, any time that the View Controller senses that its bounds are going to change, those methods will get called. Now that we've covered the View Controller lifecycle, we're now going to quickly discuss interacting with Auto Layout and the Legacy system, autoresizing masks.

Translates Autoresizing Into Masks
So in the first module, we had discussed briefly the old Legacy system for setting constraints or creating a more dynamic layout in iOS. And that was using the autoresizing masks. And there was one property the module prior to this where I told you on a view to set the translatesAutoresizingMaskIntoConstraints equal to false. And so what is this property though? And now that we're going over the view and Auto Layout under the hood, it's more appropriate now to go into detail about this property. And so this property is really useful for when you're trying to upgrade from old layout code. And what this allows you to do is this allows you to mix Auto Layout and the Legacy system. And while we're not going to go into great detail about how to do that, it is just worth pointing out that it is possible. And what Auto Layout will do is anything that can be done in autoresizing mask can be done in Auto Layout. And what this property does is it will generate constraints based on your autoresizing mask on a view. So you get the same feel as you would with autoresizing mask, but it's still Auto Layout that's generating the constraints for you. Now you need to be careful because it's generating these constraints for you, so you need to make sure that the constraints you add manually do not conflict with the autoresizing mask constraints and vice versa. We'll go into more detail about that especially when we get into the debugging Auto Layout module. Another really useful method for using this is if you need to lay something out manually, and you want your frame to be laid out manually. We've already gone through the rendering process that Auto Layout goes through. And so it would be in the layoutSubviews method that you override where you would manually place your view. And you'd want translatesAutoresizingMaskIntoConstraints set to true for this because you'd want to generate the constraint so that view would act like it typically would if you created any kind of view. If you really don't want the system to affect your frame in any kind of way, then you could set this to false. But Apple even recommends that you set it to true even if you're laying out a frame manually. And, finally, just one more thing to point out, which I pointed out in the last module, using the frame constructors for UI View defaults this value to true. And so if you're ever working with Auto Layout in code, and you're creating your views, and you're using the frame constructor, be sure to set this property to false after creating your view. Otherwise, Auto Layout's going to generate constraints for you for your view, and you're going to get conflicting constraints because you have constraints that you weren't anticipating. And setting this equal to false is not going to add any constraints for you. So it's giving you full control over Auto Layout. So just a brief look at this property. It is an important property, and it's important to understand why it exists, what it's doing, and how it can affect you, and how you can use it to control Auto Layout to its fullest.

Autoresizing Mask in Venn Diagram
So we're back in our Venn Diagram demo, and we're now going to look at autoresizing masks with Auto Layout. And we're just going to go through a simple example here. We're back in our vennDiagram class, and I've overridden the awakeFromNib function. And this gets called when a nib or a storyboard file finishes loading a view. And so all the IBOutlets and everything like that are set. And so in this method, all we're going to do is just initialize this simple view. I then grab the current bounds of our VennDiagram view and set that equal to the frame of our new view. For the backgroundColor, I gave it a light gray so we can see it. I then gave it a small cornerRadius by adjusting the CALayer underneath. And then I set the autoresizing mask. And I gave this a flexible width and a flexible height. And this is so the view will expand and contract accordingly. And then I insert the view below all the other views, so it's going to be below the Circle Views, and that's why I gave it the index of 0. And so now when I run this, you can see here that we have a light gray background behind our VennDiagram views. And I can go ahead and as the circles adjust, you can see that the gray adjusts as well, and if I rotate the device that it also adjusts. Just as a side note, you can notice that this gray background is actually going over our buttons. We're going to fix this in the next video, but let's concentrate on the autoresizing mask. But you can kind of see here that really it's kind of doing its own thing. And so if I simply go back to our view, and I comment out the autoresizing mask, then suddenly this gray area is taking up a lot more. And if I rotate it, it's taking up a smaller region. And so it's really not working in any type of way. If I uncomment them, then we're back to square one. And something else to note here is if I set translatesAutoresizingMask equal to false, nothing happens. I mean, it's still adjusting accordingly even though it's not setting up constraints now for those autoresizing masks. So the autoresizing functionality still works as it used to. But, again, it just doesn't offer the same flexibility with Auto Layout. And when we talk about autoresizing mask and this translatesAutoresizingMaskIntoConstraints, it's automatically going to handle turning them into constraints just because the constraint system is far more powerful, it can easily handle what the functionality of autoresizing masks used to handle plus a whole lot more. And so it's really best to just avoid the system completely. But, again, if you have to use it, it's there for you to use, and you could always adjust the autoresizing mask in layoutSubviews to handle any changes you might need. I just wanted to give you a brief overview of how in fact you can set autoresizing mask on a view and add that view to your View hierarchy and still have Auto Layout run and do what it needs to do.

Fixing the Venn Diagram
During the last video as we were talking about translatesAutoresizingMask, we added this light gray view as a background for the Venn Diagram, and we noticed a small error here where the gray background is actually moving into the buttons region. And if you remember, when we laid out the constraints that we set up the constraints so that this gray background would be 8 points or greater away from the top of this Left button. And so this is a really good opportunity to just quickly tackle debugging our constraints. We're dedicating a whole module to debugging Auto Layout, but this mistake is here, so let's try and fix it. And it turns out it's a really small mistake. So you see here when it's balanced, it's still really close to the buttons, and even with the left and the right. What's going on here? So let's take a look and go into our storyboard, and we'll select the Left button. And here is our constraint. And now if we look at the constant, it's priority is 1000. And when we're giving it a priority with 1000, it should be doing its best to make sure that constraint is met. And in the next module, we'll get into compression resistance and content hugging, but I can tell you neither of those at this point are playing a role in this bug. So let's move up to here. We have our Left. Top, which is our Left button, greater than or equal, and here's the issue. The second item is our Circle View, and we tied it to the bottom of our Circle View. And you can see here how the constraint's actually butting all the way up to right there. And it should be touching the bottom of the Venn Diagram here. So if we go ahead and delete it, Ctrl+Drag, and make sure it's touching the Venn Diagram, we do vertical spacing, so now we have Left. Top greater than or equal, the second item is now our Venn Diagram. Bottom, and we'll change this back to 8. And now if I Command+B to build, it looks good. Command+R to run. And now you can see that this Venn Diagram now has a much better distance away from these buttons. And if I go ahead and adjust and click these buttons, you can see that it's not overlapping. I did really want to point this out because this is an important thing. With Auto Layout, it can sometimes feel that the Auto Layout engine is working against you. And it's not giving you what you want. And so sometimes you just have to sit back, double-check your constraints, and make sure that everything is connected properly. And you'll find the problem sooner or later. So this was just a quick detour. It was a great opportunity to do some debugging with Auto Layout. And as you can see, it was very easy to fix.

Summary
So we're at the end of part 1, and we have covered a lot of great stuff. So let's quickly recap. First, we went over the rendering pipeline and how updateConstraints, layoutSubviews, and rendering work. And then we dove deeper and discussed how you, the developer, have control and can hook into that pipeline, and you're able to update constraints, you're able to adjust frames if need be, and the appropriate times you want to do that. And then we also discussed how you can do some custom drawing after the views have fully laid out as well. We then leveraged our Venn Diagram demo to really see how these steps work and how you can control them. We also discussed the role the View Controller can play during Auto Layout cycle with the will and did layout subviews. And this is your opportunity from the View Controller to make any adjustments right before the views get laid out for the first time or right afterwards. While we were laying out the Venn Diagram, we reviewed a lot of the Interface Builder tools, and we added a new one, the ability to add IBOutlets for NSLayoutConstraint. And this is a really neat product with Auto Layout--the ability to lay out these constraints in Interface Builder, connect them with an IBOutlet, and then control them from code. And then, finally, we also dove into autoresizing mask and how in the rendering pipeline during layoutSubviews, you have the ability to use this layout system. Now, again, if you're starting fresh, you should never really use autoresizing mask. But if you do come across a Legacy project for a company that was using autoresizing mask, you now know the steps you can take to work with Auto Layout within that environment. Now we've only partially completed looking at the rendering pipeline, so join me in the next module as we dive deeper into this system and we see how to build our own custom view and control every aspect of the constraint system for that view. There's a lot of exciting stuff to cover, and it's going to help you even more with mastering Auto Layout.

Creating Custom Views with Auto Layout
Introduction
Welcome to the module, Creating Custom Views with Auto Layout. In the last module, we went over a lot of topics such as when constraints are calculated and at what point in the process we can update our own constraints. We also looked at when the views are actually laid out by the system, and then we have the proper frames built out by the Auto Layout system for us to further manipulate if we need to. But what about when we want to create our own custom view? How does Auto Layout decide, Well, this part of the view is going to be the leading and trailing points on the view. And this is going to be the baseline. And so these are the topics that we're going to dive into in this module. So throughout this whole module, we're going to jump back to our Collaborate project, and we're going to build a custom Profile View. And we're going to leverage some of the techniques from the prior module with updateConstraints to dynamically adjust our constraints depending on the scenario. And then we're going to dive into topics such as the intrinsic content size, which allows you to define an ideal width and height that your view should always adhere to in the best case scenario. This intrinsic content size gives Auto Layout a lot of information about your custom view. So after having a good understanding about that, we're then going to go in and talk about the alignment rect versus the frame. And the key difference with the alignment rect is it's the alignment rect that the constraints will adhere to. And we'll see how the alignment rect and intrinsic content size pair together to make that a reality. And then you have the ability to adjust the frame accordingly if you need something a bit more custom, which we will in this module. And, finally, we're going to talk about how you can customize the baseline on the view. And by the end of this module, you will have a great understanding of all the pieces that go together to have Auto Layout work for you on any type of control or any type of layout you wish to create. So let's jump into Interface Builder and start creating our custom Profile View.

Laying Out the Custom View
We're back in our Collaborate project. And in this video, we're going to go over some changes that I made to the project, as well as adding a few things to get us set up to build our Profile View. We're in the Main. storyboard here, and I want to add a show details segue quickly to our Profile button. And, again, we're not building a full app, but the Profile page that we'll be building out will give us a chance to really show the flexibility and power of Auto Layout. So we'll just hook up this one button. So I'll actually go select the Navigation Controller so I know I have the right one. And on View Controller, go to my Main View Controller here and select the Profile button. And now I'll Ctrl+drag to the Navigation Controller and then just set up that show detail. Now you can see that there are two here. Now that that's done, in my Detail View Controller, when you generate the project, there is a label here. And I already went ahead and deleted it. You should go ahead and delete it yourself so we have a blank slate. And now I've gone ahead already, and I've started creating our Profile View class, which is going to be a custom class that inherits from UI View. And let's go ahead and take a quick look at that. So if I do Command+Shift+O, type in Profile, hit Enter, we're in our class. And hit Command+0 to give us some extra room here. Scroll to the top. Now you can see here that we have our ProfileView class, and I'm using this IBDesignable attribute so it works within Interface Builder and allows us to customize some things within Interface Builder itself. This was added in iOS 8 and Xcode 6, and it's really an incredible feature that can save you a lot of time so you don't have to constantly run your app to see how things are working. I have a few properties here--profileImageView and networkImageView. So the profileImageView will be the picture of the person, and the networkImageView will be that social network icon. In addition, I have these IBInspectable properties for profileImage and networkImage. And what that's going to let us do is if I go to Main. storyboard, I drag a view onto here, and I name it Profile View, and I go into my Attribute Inspector. You see here now that my profileImage and networkImage are here. And I can go ahead and set these to any images I need. And so this will help us as we go and build this even more. So I'm going to go back to the Profile View, again Command+Shift+O for the quick editor. And so you can see here with that profileImage and networkImage, I'm just respectively setting those images to the appropriate image view, so it's very nice and simple. You could see here that I have some constraints set up, and the reason I made these global properties for the class, class-level properties, is we're going to be modifying them to meet our needs. So I already went ahead and created them up here. And so you see here at some point we'll be setting the Profile top constraint and the Network leading, bottom, and trailing constraints. I overrode my init methods, and it's calling this method initializeViews, which we'll get to in a moment. And that's where I'm creating all the views, setting up all of the constraints to their basic fundamental level. So whether you were to create a Profile View in code or you were to use Interface Builder, it's going to go and set up the views in the same way. And here's a class level method I overrode, requiresConstraintBasedLayout. And I'm returning true. And really this is more just being a good developer. And we're using Auto Layout to build our internal views, and so this allows other developers that might use this view to ping this and say, Hey, this is going to be using Auto Layout, in case they were in some sort of environment where they're laying out the views manually or just using autoresizing masks. This at least lets them know, Well, we are going to be using Auto Layout, so just be prepared for that. And now in our initializeViews class, I'm setting the background color here to a light gray color, and we're just doing that just while we work with this Profile View, and that'll become more apparent as we get into some of the more fundamental aspects of working with Auto Layout and changing our alignment rect versus our frame. But we're getting ahead of ourselves right now. But I wanted to differentiate the background color just so it's easier for us to work with. And I go ahead and create my profileImageView. I set the translatesAutoresizingMaskIntoConstraints equal to false because I'm using that frame constructor. And I add that to our superview. We're now going to be looking at the constraint code. And to help you follow along, on the right here you can see the Profile View with the profileImageView and a circle for the networkImageView. As we go through each constraint, it will be added to this image so you can have a visual representation of it. And the current constraint that we're talking about will be highlighted in orange. And just one thing to note as well, the representation you see on the right is more what it looks like when all the code is complete and not necessarily what the view will look like after the initialization. And in here I initialize the profileTopConstraint, and I'm just setting the constant to 0 right now. And, again, throughout this module, we'll be modifying that, and you'll see why later. And then I also have my profileLeading. We have a leading constraint on our profileImageView connecting to the leading side of our superview. And that just has a constant of 0. And I add both those constraints to the Profile View. Next I have the networkImageView. And, again, we just use the frame CGRectZero, and I set the translatesAutoresizingMaskIntoConstraints equal to false and add it to my superview. I have a networkTop constraint, which is simply tying to the superview's top. And I have a networkTrailingConstraint here, and this one's a little different from the others because it's not tying to the superview's trailing view. It's actually tying to the profileImageView's trailing. So you could imagine the social network icon of that trailing and being attached to the profileImageView's trailing. And, again, we will go into detail why I did this later in the module. There is a reason. And then I have a networkBottomConstraint for the networkImageView that actually ties to the superview's top edge. And I also have a networkLeadingConstraint, which ties to the superview's leading edge. So, again, this is kind of using some nontraditional patterns where earlier we're tying the bottom to the bottom, the trailing to the trailing of the superview. We're not even following those rules anymore because it shows the power of Auto Layout, how you can mix and work with these depending on your needs. And we go ahead and add all those network constraints to our superview. There is one thing I'd like to point out in this Profile View and that's the fact that I don't actually create any constraints for my Profile View itself. And that's very important. You never want to do that internally in your custom view. Those types of constraints will always be set up outside of that view because you don't want to tie the developer's hands down. It's one thing to lay out the internal views with Auto Layout. It's another thing to have constraints added specifically to that Profile View that could impact it in big ways because as the developers add constraints of their own, they could conflict with the ones you add. So, again, we only add constraints for our profileImageView and our networkImageView, never for the Profile View itself. And now if I jump back to the storyboard here, I select the image view, and I go ahead and select Bill, and we'll select a GitHub. And now you see that there's no image for the GitHub even showing up. And so that brings us to our first issue that we need to work around. So what's going on here?

Applying Update Constraints
Now updating constraints is going to fix our problem with the social network icon not working. And that's because we really don't know the image size of it yet because when we initialized our Profile View, we set a lot of the network constraints' constants equal to 0, the networkImageView constraints, and we need to fix that. So we want to position it in the top right corner of our Profile View, and we need it to adapt depending on the size of the Profile View and the profileImageView and the networkImageView. We have our storyboard on the left side here and one of our Profile View's in the Detail View Controller. And on the right side in the assistant editor, we have our Profile View. So I'm going to go in here and override updateConstraints. One of the first things I want to do is call super. updateConstraints. And I want to make sure that's the last call because if you remember when we were talking about the rendering pipeline and how Auto Layout works, updateConstraints is going to go from the bottom and work its way up to the parent views. So you want to make sure that you call super last and don't call it first. You might get some unexpected results if you do it backwards. So now I'm going to make sure that we have both our profileImage and our networkImage. And this is great with Swift because I can go and unwrap both of these variables and enter this block if both exist because, again, they're very dependent upon each other. And if both images aren't set, we're really not going to be able to accomplish all the work we want to do. So now that we're in this block of code, I first want to calculate the leading distance for the social network icon. And so I'll create a variable here called leadingDistance, and we're going to use the profileImage and grab its width. And I'm going to multiply it by 0. 65. And so really what we want, we want it to be over to about 65% from the left of the image across to the right. And once I have that value, I can go ahead and get my networkLeadingConstraint and update the constant of it. So we'll do leadingDistance. Now we want to work with the bottom constraint. If you remember in the networkBottomConstraint, we actually tied it to the top of our superview. And we want it to be about 35% of the way down from the top of our image view. Instead of using the height of our superview, we're just going to use the profileImage itself. And so here we have networkBottomConstraint. constant and do pImage. size. height * 0. 35. You can see here that the storyboard went ahead and updated our view. So now that social icon is appearing. So this is a great workflow. We're kind of getting this instantaneous feedback. And to make sure if you're not seeing this, go to the editor and make sure Automatically Refresh Views is set to On. And you can manually have it refresh all views. And if you think there's ever an error and you have a red exclamation point, you could always debug the selected view. And sometimes it works, sometimes it doesn't. Hopefully you'll get some good feedback. And so it's really handy. So back in our updateConstraints, there's still an issue though. Look at our imageView. The top of our Profile View with our profileImageView is aligned to the top of our networkImageView, and that's not really want we want. We want it to be down a little bit, our profileImageView. And, gain, while we're in updateConstraints, we can do this. And so let's go to our profileTopConstraint. constant. And this time we'll use the size of our nImage view, grab its height, and we'll multiply it by a quarter. And you see the profileImageView there just dipped down a little bit. And now we're not quite done yet. So what happens when this networkImageView is much larger or even smaller than the trailing edge of our Profile View? Remember, we did create a constraint up here for that very scenario here in our networkTrailing Constraint. And here we tied the trailing of our networkImageView to the profileImageView, and it's set to 0 right now. But, again, depending on our images, that might not always be the case. And so I'm going to create another variable here. We'll call it maxDistance. And this is actually going to be---I'm going to use the leadingDistance that we used earlier, and I'm going to add the width of our social image view, our networkImageView. And then from there, I'm going to subtract the total size of our width. So let's take a second here. We have the leadingDistance, so we are talking about the distance from our leading profileImageView to the leading of our networkImageView. And we're taking the width of our networkImageView. And we're subtracting the total width of our profileImageView, which will calculate the space between the two trailings. And so from there, we could do self. networkTrailingConstraint. constant = maxDistance. And so it updated. Now you can see it's just a little bit offset. If I were to select this and maybe select CompactMedium, you could see it's much more apparent now where the distance is much greater. And just to prove that point, I can comment this line of code out, and you could see that our profileImageView is being stretched. And if I reapply this constant, it's no longer being stretched. So awesome! So this is really what we're looking for in getting this set up. So why don't we go ahead and just test this out by setting up some constraints. So we'll do our leading and vertical spacing to our superview, and we really don't care about the distance right now. We're just testing things out and getting our Profile View set up. So I'll just add constraints. And we're getting an error. So let's check out what the error is. Shrink our system editor here. And it's telling us we're missing constraints. So, remember, we talked in the prior module about satisfying the constraints. We need to get the position and the size. And by doing the top and leading, we gave it its position, but it still has no idea of what size it should be. And, of course, we could set the width and height constraints here, and everything will be fine. However, there's a different approach we can take. So let's go and take a look at the intrinsic content size and see how it can help us solve this problem.

Intrinsic Content Size
Let's take a look at intrinsic content size. This is really useful for giving your view a predetermined size based on its content. Perhaps the best example is the UIImageView. Its intrinsic content size is the width of the image and the height of the image. And this can be changed, of course, but it at least helps both UI kit and you to work with that view more easily. Another good example is UI label. The intrinsic content size is based on the font height and the width of the text it needs to display. So here we have Launch. However, if it was a more verbose label like We're going to launch in 3, 2, 1!, then the width of that UI label would increase drastically its intrinsic content size, or if you changed the font size, that intrinsic content size is going to grow and shrink depending on the font size. And so this is a really powerful idea to use. And by default, UI View has no preferred width or height, and that makes a lot of sense because there's no content in there. It has no concept of size because an empty UI View is simply an empty view. So let's take a quick look at the method here. We would want to override UI View's intrinsic content size, which is going to return the CGSize. So we can set both the width and our height. And another thing to point out is when you don't want a width or a height, it's best to use the constant UIViewNoIntrinsicMetric instead of passing 0. And it's a CG float, but it at least gives an indication that you really don't care about either the width or the height. And in this example, we're saying, We really don't have an intrinsic height for our intrinsic content size. Now if something needs to change after we set that initial intrinsic content size, perhaps our intrinsic content size is based on a UI text field, and the user just typed in a bunch of text, and we want to update the intrinsic content size internally on our custom view. Well, then you would want to call UI View's invalidateIntrinsicContentSize, which indicates to the layout system that you have a new intrinsic content size that you want to use on the next layout pass. It's a very simple method, and it gives you a lot of flexibility for intrinsically setting a width and height constraint internally on your view. So we're going to set the intrinsic content size on our custom view. And we have this profile picture here, and the little social media icon on the top right corner. And so what should our intrinsic content size be? Now the logical thing might be, well, it's going to be the width of the profile picture, and the width of the social media icon picture. But that's not fully accurate since we have that social media icon kind of inset into our picture. And so maybe we want to take the difference of the two widths to get our full width. But that's not what we want either. You see, if you see this dotted outline here on the frame view, we kind of want to treat that social media icon as "ornamentation" where it really has no impact on the size of the view. We want it to be ignored. Really the content that we care about is the profile picture because we want to use Auto Layout to align our custom view based on that profile picture alone and not the social media icon, which is going to change size and look different depending on the social media icon that's used. And so our intrinsic content size is simply going to be the image, the profileImage. So let's go into Interface Builder and quickly add this to our custom view.

Profile View's Intrinsic Content Size
We're once again back in our Collaborate project, and we're now going to use intrinsic content size to fix these missing constraints. So, again, we talked about the importance of thinking about what you want your intrinsic content size to be. And in this case, the content of this view is really the Profile View where that network icon is more ornamentation. We're never going to want to align to it or anything like that. And so we can come in here to our Profile View and override intrinsic content size. And then I'm going to unwrap our profileImage. So if it's set to nil, then I don't want to set the intrinsic content size. And here I can actually just return the size of the image. However, if we don't have it, then I want to return CGSize and use the special value UIViewNoIntrinsicMetric. And I want to set that for both the width and the height. And, of course, you can just call super. intrinsicContentSize, and it's going to return this because we know UIView doesn't have an intrinsic content size. And so you see here the storyboard just updated. And now it's telling us here we no longer have an error, we simply have a warning. It's saying, Well, your expected size should be 55x55, but I actually see that your view is this size. And we can go here and update frames. And now you see another issue here is the fact that we now have some clipping. I mean, the image is the appropriate size for the profileImageView, but if I go ahead and run this here, you can see that it's off-center. And we have the networkSocialImage, which is kind of going off the view. The profileImage is going off the view. And that's because there's a discrepancy between all of the content in there and our frame size. And so the issue with this is there is a discrepancy between the size of our alignment rect and our frame. And so let's take a look at this and see how we can solve this issue.

Frame vs Alignment Rect
So if you're an experienced iOS developer, you are very familiar with the frame for UIView. And this frame is something you would have manually set or maybe used some of your own math to set it in the past. And one of the benefits of Auto Layout is the fact that it's going to calculate the frame for you based on the constraints that you set. However, when we're talking about what part of the view does Auto Layout align to, it's not the frame, nor is it the bounds or any other of the rectangles we've used in the past on UIView. It's something called the alignment rect. And now the two are very similar. However, the alignment rect is what Auto Layout uses when you're going to define your leading, trailing, top, and bottom for your view, and it doesn't have to encapsulate every part of the view itself. For instance, take a look at this slide here, and we have a profile picture of my partner in crime here hard at work editing the video. And in the top right corner of his Profile View, we have a decoration with the social media icon. And now whenever we lay out these views, though, all we care about is the profile picture because we don't know what social media icon's going to be there, whether it's Facebook or GitHub or Twitter. And so the size could change depending on that. And we don't want our constraints to be skewed because of the changing image size. And so it's with the alignment rect that we establish the boundaries for how Auto Layout is going to utilize the constraints we add to this view. And so how do we set it? Well, this is an odd thing when you're first starting out. The alignment rect can be set with your intrinsic content size. And so whatever we establish as our required size for a particular view, that would be our alignment rect. And then we can simply adjust the frame of our view based on where that alignment rect is. And now how do we do that? The easiest way to do this is to override the method alignmentRectInsets, which returns UIEdgeInsets. And now you can see here a very simple example where I just create a UIEdgeInsets, I'm giving a bottom 10 and right 10, and it just adjusts the frame accordingly. And if I want the frame to be smaller, I can just provide it negative numbers to make the frame smaller than the alignment rect. And now something to note here, and this tripped me up the first time I overrode this method as well, I was originally under the impression that alignmentRectInsets wasn't adjusting the frame, but it was adjusting the alignment rect, and that's just not the case. What happens with alignmentRectInsets is the alignment rect is already calculated, as I said, based on the intrinsic content size, and the values you provide and return in this function will change the frame size, not the alignment rect size. And that is a very important difference. And you'll see it in the demo how it will impact how our view looks when you see how it adjusts the frame the way it does. Now this is a very simple example where we're not always going to be passing strict values like 10 and 10. Especially with something like our social media icons, we may have to do a bit of calculation and change the number that's being returned for the edge insets accordingly so we have a proper frame for our view. And if alignmentRectInsets doesn't suit your needs, you have two other methods at your disposal. And they need to be called together. And so you need to override them. And that's alignmentRectForFrame and frameForAlignmentRect. And instead of returning UIEdgeInsets, you would go ahead and return a CGRect. And you would adjust the values accordingly for that CGRect. And now the very important part of this is if you override these two methods, you have to make sure that they are the inverse of each other. So if you see on the example here on the right where I'm adding 10 to the width and I'm adding 5 to the height in this one for alignmentRectForFrame, you can see that in frameForAlignmentRect that I am subtracting by 10 and subtracting by 5. So, again, they must always be the inverse. And if they aren't, you're going to get results that you aren't expecting, and things could be off, and it could be very challenging to debug. So always remember that. We're now going to jump back to our project. And in Xcode, we're going to override alignmentRectInsets and see how we can leverage this in our custom Profile View.

Adjusting Profile View's Frame
We're back again in our Collaborate project. I went ahead and added a couple more Profile Views so we can really see the impact that alignmentRectInsets is going to have on our views. And so I just added one here and tied the bottom constraint of it to the top constraint of our original view and set some horizontal spacing. And then this one I aligned the trailing of these views and just added some vertical spacing. And going and running this, you can see here that our frames are just wrong. And not let's use alignment rect to get this working properly. And there are a couple of ways you can actually see the alignment rect. The first one we'll go over is if you go to Editor, Canvas, you could show the Show Layout Rectangles. See, I already have it selected. And if I unselect it, the rectangles go away. This gives you a good indication of what your alignment rects look like. And, finally, you could also check out the size of the alignment rectangle here, and you see right now as I select the frame in the alignment rectangle, these aren't changing, and that's because they're equal at the moment, which is something we're about to change. So I'm going to go into our ProfileView class. We'll make some more room here, scroll down, and do alignmentRectInsets and override this. And I want to calculate one distance first because if we have a smaller social network icon, for instance, if this one were Facebook instead of GitHub. I'll comment this out quick since it's breaking Interface Builder. You can see that the edge---it doesn't even go off the edge of this profileImageView, so we want to calculate a distance here that makes sure if it's less than the width of the profileImageView, we don't want to subtract anything. So we'll use our networkTrailingConstraint, and if it's negative, that means that our networkImageView is smaller than our profileImageView. It's not going off the edge. But if it's larger, then we'll simply set this to the constant of the constraint. Otherwise, it's 0. And now we can return our UIEdgeInsets. And for the moment here, I'm just going to set these all to 0. We don't need to adjust the top or the left, but the first one we want to adjust is the bottom. And here we'll use the profileTopConstraint. constant because we offset that profileImageView depending on our network image. And so we want to reset that offset back again so the frame goes all the way to the top for us, but also so our constraints are still aligned appropriately to the top of that Profile View. Again, we don't care about that networkImageView, and that's why we're going to this work because we want to make sure our constraints are used on our profileImageView only when other developers are using this custom view. And I will set the right side, and we'll just set that to our maxX. So, again, it will align itself appropriately depending on if that networkImage is going past the trailing edge of our profileImageView. That's it! If I go and run this now, you can see here that the frames are now the correct size. Our Facebook one is going appropriately up to the edge of the profileImageView. And our GitHub and Medium ones are going all the way to the end of the networkImage icon. So this is great. If we come here, you can see that our frame rectangle and our alignment rect are different sizes now. There's a small discrepancy here in Interface Builder. Our frame rectangle is not 55x55. We know that because our intrinsic content size is 55x55, and we just adjusted our alignmentRectInsets. And just changing the size of one of these should get Interface Builder to update itself appropriately. And now you see we have some yellow issues here, and I can go to my View hierarchy. And now it's saying, well, this should actually be 55x55, and it's trying to update it. And now it's giving a different error message too because it's saying, well, I expected 55x55, but it's measuring at a size greater than that, and that's because we just adjusted our frame. So it's getting confused because it's trying to read the intrinsic content size, but we're applying this alignment rect, and it's having trouble rectifying it. So there are essentially two ways we can fix this. The first and the easiest way is to simply make sure all the networkImageViews and our Profile View are not set in Interface Builder. And this makes sense because the intrinsic content size is the Profile View and if we get rid of that networkImageView, then the size will be 55x55, and the warnings will go away. The second alternative is to use the intrinsicContentSize placeholder. Our intrinsicContentSize here on our view, right now we have Default (System Defined), which is using our method, and we could just put a placeholder in here and set it ourselves. So for this one, we want 60. And now that's set. And for this one, we can put a placeholder. And this is 62 and 60 respectively. So I'm not going to set all of them in this video, you get the idea. And it might take a few tries as they kind of keep adjusting themselves. However, this isn't the cleanest approach. It's nice because that placeholder will have no impact on the actual intrinsic content size runtime. This is purely for Interface Builder. However, it is the wrong intrinsic content size, so even though it'll make the warnings go away, your views are going to align as if that networkProfileView is part of the alignment rect, which really isn't what you want. So the better approach is the first approach, which is just getting rid of that networkImageView. And it's the cleaner approach too. And there is one other thing I would like to show you. If you would like to view the alignment rects while you're running the app, you can do that as well. And there's an NSUserDefault key that you can use called UIViewShowAlignmentRects. And if you set that equal to Yes, it will draw, it will render the alignment rects for you when you run your app. And we don't need to set that in code. We could come here and just edit the scheme, come to Run, and come to the Arguments Passed On Launch. And I'll just do it here, include the -UIViewShowAlignmentRects YES, close. Now I'll rerun my app. And you can see now that we also have the alignment rects here. And so this is really cool! This is really powerful. And you see here it's drawing all the alignment rects. So not only do we have our Profile View, but we also have the profileImageView, our networkImageView, alignment rects, so we can see everything. So just another handy tool to put into your belt to help you try to troubleshoot any issues you might be having. So it's really powerful, this combination of the updateConstraints, intrinsicContentSize, and alignmentRectInsets. We're able to take full control of Auto Layout and also dictate how we want our user interface elements to be aligned. It doesn't have to just be the frame and the edges of that frame. You have a lot of powerful control here that you can use that's at your disposal. And it takes a little bit of getting used to, but it's just a matter of setting everything up right and thinking about it within the context of what Auto Layout is going to do with it. As long as you have that mentality, you'll be able to do whatever you need to using Auto Layout.

Modifying the Baseline Alignment
So we're now going to take a look at setting the baseline for our UI View. And now this is really easy to do. There's one function that we override in UI View, viewForBaselineLayout. And we return the UIView, which we want our baseline to adhere to. And now this is a really powerful method. And let's take a look at it in Interface Builder with our project. We're now going to just run through a quick baseline demo. Even though we're not going to use it for this custom view, it's really easy to show even on this particular example. The first thing you want to make sure is that you're still showing your layout rectangles, so go to Editor and select Show Layout Rectangles if they're not showing. And right now it defaults to the bottom of the UI View, so we really don't see any difference because of the baseline. So I'm going to come into our Profile View and override viewForBaselineLayout. And I'm simply just going to return our networkImageView, and when I do that, you can see Interface Builder updated, our storyboard updated here, and we have a line going across, and it's just at the bottom of that networkImageView. And you can see it on all three of these. And it's really nice. So I could take a label now, set it, and set up constraints, and I could do select horizontal, top, and baseline and add these three constraints. And it's now adjusted to the baseline between those two views. So it's really powerful, and it's really cool.

Summary
We're at the end of the module, and we covered a lot of cool stuff. And just to recap, again, one of the biggest challenges with Auto Layout is understanding how it's working under the hood. And so in this module, we concentrated on creating a custom Profile View. And with that, we were able to dictate what the leading and trailing and top and bottom constraints should be. And we first did it by setting up our custom view with our profileImageView and networkImageView and laying out those internal constraints. And then we leveraged updateConstraints to update those constraints depending on our needs. We then dove deeper into the internals of our custom Profile View. And the first thing we looked at was the intrinsic content size giving it this default width and height that it should always have because, again, a UI View has no intrinsic content size. But since we had content in there that we want displayed, it made sense to set this up. And so when we're laying out our constraints, we can give it an XY position, and we don't necessarily have to worry about the width and height because the intrinsic content size is already providing that knowledge. And, of course, we could always override the intrinsic content size with our own constraint. And then we looked into the difference between the alignment rect versus the frame. Now when building views, we're typically used to working with the frame. But the alignment rect is how you determine where the top, leading, trailing, and bottom constraints should be. They don't necessarily have to be where the frame edges are. They could be elsewhere. And then, finally, we also looked at how you can customize the baseline. And so it's all really cool stuff because it gives you the power to do whatever you need with Auto Layout especially when building your own custom views. Now there's one more important part that we need to go over about the rendering pipeline, and it impacts the priority certain views will have over others, especially if they have an intrinsic content size. And those two concepts are the compression resistance and content hugging. So let's go to the next module and see why these two concepts are so important and how you can leverage them to control Auto Layout even more.

Leveraging Content Hugging and Compression Resistance
Introduction
Welcome to the module, Leveraging Content Hugging and Compression Resistance. Now up until this point, we have looked at the whole process of how Auto Layout will lay out views and calculate constraints. We've built a custom Profile View and saw how we're able to dictate where the top, leading, trailing, and bottom are on particular views and how we can even dictate an internal width and height through the intrinsic content size. Sometimes there is an issue with your layout. And say you go ahead and lay out a couple of buttons across the screen, and you lay out your constraints. However, there's conflict between the intrinsic content size of those particular UI elements, let's say buttons, and the constraints that you laid out leading to an ambiguity. Essentially there's a tie, Auto Layout doesn't know what to do, and this is why we have the concepts of content hugging and compression resistance. So in this module, we're going to take an in-depth look at content hugging and compression resistance. We're going to review how we can adjust these in code, and then we're even going to go ahead and look at how you can modify them in Interface Builder. And we'll use our Profile View along with the UI button and UI label to get a really good look at how the issue of ambiguity is caused in the first place and how we can leverage these two concepts to fix those issues. And it's a really important topic because it's an issue you're going to run into time and time again. And it's important to know the difference between these two so you can make the right decision and get the layout that you want because just guessing and lowering a priority on one or the other could lead to issues, and you're going to be wondering why your user interface isn't laying out the way you want it to. So let's dive into the material.

Content Hugging and Compression Resistance
So let's talk about content hugging and compression resistance. Now they're going to be certain scenarios where you lay out your constraints, and there's not going to be enough material for Auto Layout to be able to properly lay out the views. And that's where content hugging will come in. Or the alternative is, there's not enough space. Even though you laid out your views, the amount of space that's given on the device, say you have a 4-inch iPhone, something's going to get compressed. And that's where compression resistance comes in. And so what are these exactly? Well, they're extra behaviors that give you more control over the Auto Layout system. And it's one of those instances where you're not getting the exact layout you want, but Auto Layout's going to try its hardest to get to the layout you're looking for. And the content hugging and compression resistance could be that extra push in the right direction for you. So one important thing to note about content hugging and compression resistance is that this really just impacts views that use the intrinsic content size. And as we dive deep into this, this will make more sense because if you have two views that have a specified intrinsic content size, but the constraints don't meet that intrinsic content size requirement, then Auto Layout needs extra information to be able to lay out those views properly. And that's one of the most beautiful things about content hugging and compression resistance because it gives you these extra behaviors that you can control in Auto Layout to lay out the views exactly how you want them to, even if it means you breaking the intrinsic content size for a particular view, such as UI button or UI label. Now these are different from normal constraints that you would build in Interface Builder or add directly in code. Typically, constraints that you create will default to the priority of 1000, which means they're required. However, content hugging and compression resistance don't follow this pattern. They default to lower priorities. And content hugging typically starts around 250. There are some subtle differences between some controls. For instance, the UI button is 250 but the UI label is 251. And then compression resistance is higher at 750. And, again, what are these good for? Well, it gives you more control, and it helps resolve ambiguity. Again, sometimes Auto Layout might just say to you, Well, I don't have enough information, and these can help you give it that extra information that it needs. So let's first take a look at content hugging. So you can see here on the screen, we have our phone, and we have a button that says Launch! and an image of a spaceship. And we have these three constraints laying out, and you can imagine that they're just saying, Well, I want the left edge of the button to be 8 points away from the left edge of the screen. I want there to be 8 points between the button and the image. And I want there to be 8 points between the right side of the image and the right side of the phone screen. However, Auto Layout's not going to like this, and that's because look at the frames. The intrinsic content size for these frames for the UI button is around the text of the button itself. And if we look at UI Image View, it hugs right around the image. And you're going to get an ambiguity or an Interface Builder saying, Well, there's just not enough information here. And, in fact, Interface Builder's going to take it a step further and say, Why don't you try adjusting the content hugging? So let's take a look here. Let's say the horizontal priority for content hugging is 250 for the image and 250 for the button. Well, one of these needs to change, and that's because they both have equally content hugging, so the frames are just going to try to stay at that intrinsic content size and stay as close as it can to the material within the view. So it's trying to stay within the button, or it's trying to stay within the image. And now in this example, we want our button to actually take up more space. And you can see that with this green dotted line here. And this is the space we want to take up. So if we were to adjust the button's priority to 249, then it would expand to this green frame and take up the space that we want it to because we're giving Auto Layout that extra information it needed. We're now telling it that we want the button to have a lower priority in terms of the frame hugging its content and that the intrinsic content size can kind of be overridden here and expand to meet the required constraints. And so this is a really useful technique especially when you want things to be laid out across the screen from left to right, but your content doesn't necessarily take up all that room. And compression resistance is the exact opposite. So now you can see here our button's been replaced with a label, and we have this long message that's taking up too much room on the screen. And, in fact, it's taking up so much room that it's squeezing our Image View on the right side. And so now our image is kind of being forced and being crushed, and it just doesn't look good. And taking a look, our image's horizontal compression resistance priority is 750, and our label is 751. So this is saying, Well, if the label's larger, we'll just shrink the image down to make more room for the label. And this isn't exactly what we want, is it? I mean, it's not exactly the ideal. However, this is happening because there's just not enough room to meet the constraints that we've set up. And now there are multiple scenarios to fix this. In fact, the first one would be, well, let's lower the compression resistance of our label. And when that happens, you can see here that the image is now its normal size, and the label has been truncated, and it's ending with a... And now maybe this isn't what you would want either, but it drives the point home about what the compression resistance is doing in this example where we're giving the image a higher priority and saying, Now, if all else fails, make sure that one doesn't compress over the label. Now perhaps you don't want the label to look like that. So don't forget you have plenty of other tools besides compression resistance to fix this. For instance, we could add an aspect of ratio constraint to our Image View and so it will automatically adjust the height even though our label is really long, and that compression resistance is forcing the image size to shrink. Or another option is we can change the number of lines on that label, and suddenly if the constraints allow it, the label can write multiple lines of text and not impact the images width whatsoever. And so, again, content hugging and compression resistance are just another tool in your toolbox to help you get what you want with Auto Layout.

Controlling Hugging and Resistance in Code
So let's take a closer look at how we would use content hugging and compression resistance in code. It's on the left here, you can actually see an Interface Builder in the measurement menu where content hugging priority and content compression resistance priority are located. And here you can select the horizontal and vertical for each individually. And so whenever you're in Interface Builder, this will be the area where you go and change it. However, what about in code? What would you call? Well, UI view has setter and getter functions for content hugging and compression resistance. So looking at the setters first, we have setContentHuggingPriority. And we're going to pass in a priority and an axis. We also have the same for setContentCompressionResistancePriority where we pass in a priority and an axis. And now let's take a quick look at those values too. So, with UILayoutConstraintAxis, you have Horizontal and Vertical, which matches what we see in Interface Builder. You can set either one to suite your needs. They don't have to be the same. And then UILayoutPriority, and here you can see we have several constants. And one is Required, which equals 1000. And this is the same value that's used whenever you create any type of constraint by default, whether it's in code or in interface builder. And then we have DefaultHigh, which is 750, which content compression typically defaults to. Again, there are a few exceptions depending on what UI control you might be using and UI kit. And then we have DefaultLow, which equals 250, which content hugging typically defaults to. And then we have this FittingSizeLevel. And we're going to get more into fitting sizes during the dynamic text module of this course. However, it's such a low priority here, 50, that this is going to be a priority you give a constraint when you want the Auto Layout system to take that constraint into consideration. However, with such a low priority, the likelihood of it taking effect is almost non-existent. And so that's when you would use it in that case. I personally have never had a reason to use it, but it does exist. So let's look at an example quick. So we have our own custom view, and here we want to set the content hugging priority to 249. And so here I just call our SetContentHuggingPriority, and I use the UILayoutPriorityDefaultLow -1 for our horizontal axis. And now, of course, you could just put 249 here. But it's best to use the constants. They're provided to you by Apple, and it's good to keep within the range that they recommend. Even though the priority range goes from 0 to 1000, you really want to try to keep within the 250, 750, and 1000 range and just adjust some slightly as needed so you don't lose control of your whole priority system and it becomes a pain to maintain. And now, too, using the constant, of course, if Apple every decides to change what DefaultLow means, your code will automatically update appropriately. And then we do the same for SetContentCompressionResistancePriority. And so we have DefaultHigh +1 to set it to 751 on our vertical axis. And if you look to the left here, on our Interface Builder section, you can see the same values being reflected as what we set in code. An now let's quickly look at getting. The getters are far more simple. So all you need to provide is the axis that you're looking for, and you'll get the value of that priority back. So in this instance, we're calling view. contentHuggingPriorityForAxis horizontal. And then underneath we're getting the CompressionResistancePriority for the vertical axis. So they're very easy to use in code. They're very easy to adjust in Interface Builder. And now let's go into our demo, and let's take a look at the impact that content hugging and compression resistance will have in our project.

Demo: Content Hugging
We're back in the project, and let's take a look at content hugging. So I have a button here that I laid out and sized already. And now I'll hook up the constraints. And all I'm going to do is I'll add a horizontal constraint to its closest Profile View. And I'll add a trailing and vertical to the superview. And it's giving me this content priority ambiguity. And this can be resolved with content hugging because it's not going to be able to fit these views properly. And it's looking to try to get one of them to have priority over the other. Right now the button content priority is 250, and the Profile Views are 250 as well. So, first, why don't we go to this Profile View, and we will set this to 249. And when I do that, you can see that this frame is trying to extend out because I lowered its hugging priority, so it's just saying, Okay, I'm going to fill that extra space. And my button said, Oh good, well, my appropriate size would be this dashed line that you see right here. And maybe we don't want that though. Maybe we want the button to take up this whole space, and we want the Profile View to really just hug its own content. We want that to have the priority. And so I don't even need to re-up that Profile View to 250 again. I could just lower this one to 248. And now you see it readjusted again. No longer is this Profile View trying to extend out like it was. And the button is now taking up the appropriate width that you see here on Interface Builder. And so I can go and run this, and we see that it didn't impact this Profile View in any way. And the button is taking up this whole space even though you can't see it. So it's a really powerful concept. And in combination with compression resistance, it allows you to get the correct priority. So let's take a look at compression resistance and see how it's different from content hugging.

Demo: Compression Resistance
So we're back in the project, and we're going to check out compression resistance. I already added a label with a really long title to it so it will go beyond the bounds of the actual label frame itself. Let's set up our constraints here. So I'm just going to quickly put some horizontal spacing between the closest Profile View, and then I'm going to connect trailing and vertical constraints to our superview. And now you can see here I get this content priority ambiguity. It's telling me that I could adjust my compression resistance to take care of this. And so what's this saying though? It's saying, Well, there's not going to be enough room to show all of this content. Yet, when it comes to the content compression resistance priority, all of these are 750, even my priority views. So which one should get priority? Essentially, I could do this in two ways. I could either lower the priority of the three Profile Views and give the label the maximum amount of room to show its content. Or I could lower the label's priority and tell it to give the Profile View's priority in terms of showing all of their content. So I could just come here to Content Compression Resistance for our label and set it to 749. And I only need to adjust it by 1 since the Profile Views are 750, and this satisfies it. And now what you see is when I run this that it has compressed the label as much as it can, and it's not affecting the Profile Views in any way. And now if I were to reverse this though and change this to---we'll lower these by 2 since our label is still 749, we'll lower these. Suddenly, the label's going to have the priority. And when we run this now, Auto Layout's going to try its best to get as much of that label shown as it can at the expense of our Profile Views. And now the way we've built our Profile Views, we really didn't adjust the aspect ratio or the size of the images, so those aren't being compressed at all. But you could see the gray bars here, which is our frame size. They're being compressed in a lot. They're no longer covering our full content. You can see here how compression resistance works. It's giving the label now the priority. And even though it's still hot showing the whole label, it's trying its best to show as much of it as it can at the expense of the Profile View. When you're in those scenarios of trying to give a preference to one view over another, you can do that with compression resistance and content hugging.

Reviewing Auto Layout's Pipeline
So we have covered a lot of material over these last three modules. Now let's quickly bring everything back together and summarize Auto Layout's rendering pipeline. So in part 1, we started by concentrating on the rendering pipeline itself, and we went through the three stages that Auto Layout's going to go through to lay out and render all the views. And that was updateConstraints, which works through the View hierarchy from the bottom up. And then layoutSubviews, which will go top down where it's laying out the frames. And, finally, the rendering phase. We're able to leverage that knowledge, as well as functions within UI view to hook into that process and leverage it in our own views. And we found that it was very easy to update constraints. And we now know when we have the correct frame size if we need to do anymore manipulation and at what point we have all the frames so we could safely render any custom drawing that we might have. We then looked at the View Controller and the role that plays in Auto Layout and how you have the ability to detect when a layout is about to occur for the view that's attached to that View Controller. And this is a very powerful mechanism so you can do any pre- or post-work before Auto Layout lays out the views. Further leveraging this knowledge, we then looked at the old Legacy system with autoresizing masks and how you can still use them even though we're using Auto Layout and how in layoutSubviews is where you would want to make any changes to those. And this, again, is one of those if you're starting out fresh, use Auto Layout. However, if you find yourself in need to using autoresizing masks for any reason, you know you can. And you know how to do it safely now. After that, we then drove into part 2. And we analyzed a custom view where we created our own Profile View. And we tried to answer all of the questions of, Well, how does Auto Layout determine where the leading and trailing constraints should be or the center X and center Y or even the baseline? And we first started by leveraging what we knew from part 1 to lay out our view. And then we started getting into some issues. And we resolved them step by step. And so the first one we looked at was the intrinsic content size, which gave us the ability to define a width and a height for our view. We then saw how the alignment rect would be created based on the intrinsic content size that we made in our view. We were able to customize the frame of our view while ensuring the alignment rect, and our constraints aligned up exactly as we wanted it to. And so we had a special social media icon in the top right corner of our Profile View that we were able to have Auto Layout ignore when laying out our views. And so, again, it's very powerful. And it puts you in control of every aspect of how Auto Layout will interact with any of your custom views that you create. We then looked at content hugging and compression resistance and how intrinsic content size plays a role in those and how you can leverage content hugging and compression resistance to resolve issues you might see in Auto Layout. And, again, typically, the issues are caused by certain ambiguity because certain views, such as UI buttons, have an intrinsic content size, and either they're not taking up enough room to meet the needs of your constraints, or they're taking up too much room and need to be compressed. And so leveraging content hugging and compression resistance gives you the tools you need to decide how you want everything to lay out. And you can think of them as a way to override the intrinsic content size for a particular UI control that has it. And, finally, we went over how to set the baseline. It just goes to show you how Apple took a lot into consideration when it developed the Auto Layout system. And it made sure that you as the developer have the ability to work with it in any way that you need to. And so you've done a great job going through these last two modules and getting a firm understanding of Auto Layout. So let's go to the final module of this course and look at how we can simplify using Auto Layout with the UIStackView, the anchor APIs, and the active property on NSLayoutConstraint.

Simplicity with UIStackView, Anchors, and Activating Constraints
Introduction
Welcome to the module, Simplicity with UIStackView, Anchors, and Activating Constraints. Up until this point, we've used Auto Layout in two different ways. We've used Interface Builder to lay out constraints, and we've also used the standard NSLayoutConstraint API. And Interface Builder will go ahead and take care of the adding and removing constraints for us. And then in NSLayoutConstraint API, we were using addConstraints. And while we never called removeConstraints, there is a function that does that as well. And now on all of these levels, though, there is an easier way. And in iOS 8 and iOS 9, Apple has introduced new methods for working with constraints that make our lives easier. And so we're going to review all of those in this module. And we're going to apply them to our Collaborate project. And we're going to start with the active property on NSLayoutConstraint. And this is a really important property because it takes care of adding and removing constraints, and it finds the common parent view between two views for us so we don't have to, which makes it a lot simpler in code to add and remove constraints versus the old method because with the old method, you would have to find the parent view and call addConstraints on that function. We're also going to look at the NSLayoutAnchors, and this was added in iOS 9, and it was a great addition because the NSLayoutConstraint API is extremely verbose. And you can use a visual format language, which, again, we're not covering in this course. However, in iOS 9, they introduced a simpler way, and that's using these anchors. And so we're going to take a look at those in depth, and we're going to take a look at the subclasses for NSLayoutAnchors such as the NSLayoutXAxisAnchor, the YAxisAnchor, and dimensions, which apply to width and height. And you'll see by the end that they're really easy to use. So at this point, we're going to jump back into our Collaborate project, and we're going to update our custom Profile View to leverage both the active property and these anchors, and you'll see we're going to remove a lot of code, and the code base is just going to be more readable once we're done. And, finally, we're going to take a look at the UIStackView. Now this was introduced in iOS 9, and this is perfect when you need to lay out simple grid-level UI type of objects. It takes care of adding the constraints for you so you don't have to, so you can vertically stack objects, horizontally stack them, space them, and do many other things. And it's a very simple view to use. And it's one of the most powerful additions to UI Kit. And you'll see this in the Collaborate project because we're going to replace our menu that we built in Interface Builder with one UIStackView. And we'll be able to delete 95% of the constraints from that view because the UIStackView's going to take care of everything for us. Now if you've watched Jordan Morgan's course, What's New in iOS 9, here at Pluralsight, it's an excellent course, you've already seen some of this material with the NSLayoutAnchors and the UIStackView. However, I'm trying to tailor the material to apply what we've learned in the earlier modules to really take this to the next level and utilizing those core fundamentals that we've learned throughout this course with Auto Layout to expand on not only the active property but NSLayoutAnchor and UIStackView as well. So if you've watched that course, some of this material might not be completely new, but hopefully you get something new out of it. So with that being said, let's take a look at the active property for NSLayoutConstraint.

NSLayoutConstraint's Active Property
When you're dealing with constraints in code, a common problem you might run into is it can become very complex to deal with multiple constraints between multiple views and what constraints tie to a particular parent view. And you have to wonder, Is there an easier way to deal with all this? Well Apple went ahead, and in iOS 8, they introduced the active property. It is by far the safest way to add and remove constraints. It's a simple Boolean. And in this video, we'll take a closer look at what it does and the APIs that you can use to call it. It's important to note that only active constraints affect the layout. So if you have a set of constraints where the active property is set to false, they are not going to impact the layout of your views in any way. And, finally, whenever you create a new NSLayoutConstraint, this property sets to false by default. So here we have a small View hierarchy with a parent view and some subviews with view 1, which has more subviews, A and B, and then we have another subview under parent view, which is C on the right side. And now let's say we want to have a constraint between A and C. Well, if we use the active property, what it's going to do is it's automatically going to find the common ancestor between these two views, which in this instance is the parent view. And so this is great. It takes care of the more important maintenance work as we add and remove constraints. And under the hood, that is all this is doing. It's just either adding or removing constraints, and it's finding the common ancestor for us so we don't have to keep track of it. Now it's important to note, though, that if you try to set the active property to true on a constraint where there is no common ancestor, it will throw an exception, so don't do it. Even through this does a lot of great work in terms of bookkeeping for you, you do still need to think about the constraints overall and making sure that the constraint ties to views within the same View hierarchy. So let's take a quick look at the API on NSLayoutConstraint for this. Well, first, we have the active property, which is a Boolean, which you can get and set. And then there are also two convenience functions as well, and the first one is a class function called activateConstraints, which will take an array of constraints, and then the other one is a class level function as well, deactivateConstraints, which will take an array of constraints. And these will either add or remove depending on which one you call. So now that we've gone over this really powerful property, later in this module, we're going to jump back into our Collaborate project and leverage the active property to simplify our Profile View code that we built earlier in the course. But, first, let's take a look at another technique Apple has created for creating constraints and simplifying our code base, and that's the NSLayoutAnchor.

Anchors and Dimensions
One of the most challenging things with working with the NSLayoutConstraint API is its verbosity. And there's a visual format language, which, again, is outside the scope of this course. It has its own advantages and disadvantages. But Apple went ahead and found a new way to simplify working with NSLayoutConstraint in code without the visual format language or the verbose NSLayoutConstraint API, and that's using NSLayoutAnchor. Now here you can see we have a phone with a label in the center. And now it's important to view the phone from its frame. So we have a UI View here or a UI Label, and we have its bounded edges. And now with NSLayoutAnchor, we have subclasses of NSLayoutAnchor which really bring together all the constraints that you can build in code. For instance, we have the NSLayoutXAxisAnchor, and this applies to the left and leading anchor on a view, the center X, and the right and the trailing. And then we also have the NSLayoutYAxisAnchor, which involves the top anchor, the first base line, center Y, baseline and last baseline, and the bottom. And this is really nice because it creates a clean separation between the X and the Y axis type of constraints that you can build. With the NSLayoutConstraint API, there's nothing stopping you from creating a constraint between a top edge and a leading edge. But at runtime, it's going to break and fail on you because it just doesn't make sense. So here there's some type checking and a lot more can be done while you're coding to check, Hey, okay, you're trying to mix these two different types of anchors. And then there's also the width and the height. And the class for the width and height is the NSLayoutDimension. And now this also derives from NSLayoutAnchor as well. So, again, it takes all of these different constraints and just breaks them down into their abstract components--X axis, Y axis, and dimension. Now let's take a look at the API. The first function that we have is constraintEqualToAnchor, and we're going to do a demo in a minute where you're going to see this function called a lot. In here, you would just go within your view, for instance, self. TopAnchor. ConstraintEqualToAnchor and then pass in another view and another anchor along with a constant and you'll get a constraint back. There's also a GreaterThanOrEqualToAnchor and a LessThanOrEqualToAnchor. And then these functions also have siblings which don't have the constant parameter, which would just set the constant to 0, which is a common pattern that you do anyway. So it's very nice, and it's much cleaner. So let's jump into Xcode into our Collaborate project and update our Profile View's code to use these anchors instead of our NSLayoutConstraint API code. And on top of that, we're also going to use the active property instead of the Add constraint, and you're going to find that we get to delete a lot of code, and it's much easier to read and a lot cleaner, meaning it's more maintainable. So let's check it out.

Update Your Profile View's Internal Constraints
So we're back in our Collaborate project. And we're going to take the custom Profile View that we had built in the prior module, and we're going to simplify the code base by leveraging both the active property on NSLayoutConstraint and using some of the factory properties that are provided by that NSLayoutAnchor. And now this demo won't use the NSLayoutDimension, but the process would be the same if you were working with widths and heights instead of the top, trailing, leading, and bottom type of constraints. So we'll go constraint by constraint here, and we'll just keep working our way down, and you'll see by the end of this how much code we can delete and how much easier it is to read the code that we are about to write versus using the old NSLayoutConstraint API. So we have our profileTopConstraint here. So, again, we still want to set any class level constraints that we're saving because we are modifying these throughout the Auto Layout lifecycle during updateConstraints and layoutSubviews. So it's still important that we save these. What you want to do then is just using this NSLayoutConstraint guy, we can just simply read and work our way down because there's really nothing special with these constraints. So that's why the NSLayoutAnchors work so well. So our first item is the profileImageView, and our attribute is the top, so we'll use the topAnchor. And then we can say constraintEqualToAnchor. And all we need to do is pass in our self as the topAnchor. And that's it. Just one line here instead of the nine lines that we were taking up before. And then another thing I'm going to do here too is now that we've set this constraint, I'm also going to go ahead and set the active property on it, not profileImageView but profileTopConstraint equal to true. And now this is going to go ahead and find the superview for us and add it to our parent view. So we can just go ahead and delete those nine lines, and we're left with two lines. And so now here we go, we have the leading of our profileImageView connected to our leading of our superview. So let's quickly go ahead and do that. And now you'll notice too that we're not saving this on the class level height because we don't adjust it at all. So we can go ahead and do this one in just one line. And all I'll do is self. profileImageView. leadingAnchor. constraintEqualToAnchor(self. leadingAnchor). And then I can just right here go. active = true, and it'll generate the constraint and add it. And we don't need to do any more work. And you see here we have this self. addConstraints, and we don't need that anymore. We always want to add and remove constraints using the active property because it's safer and it's cleaner. So let's go ahead and delete that line of code and come up here and delete our original leading profile. So here we have a block of code where we're adding our networkImageView, setting translatesAutoresizingMaskIntoConstraints equal to false and adding that subview. And now we go ahead and have our constraints for this networkImageView. So, again, this is a local constraint here so I can just go ahead and do this all in one line. So I'm going to do self. networkImageView. topAnchor. constraintEqualToAnchor, we're attaching it to the topAnchor of our superview,. active = true. There you go. It's going to create and generate the constraint. And now we have this trailing constraint here, which is a class level constraint. We're saving it because we're going to be modifying it later. So we do want to save this one. So we'll do networkTrailingConstraint = self. networkImageView. trailingAnchor. constraintEqualToAnchor(self., in this instance, it's our profileImageView. trailingAnchor. And then we can go ahead and call active on that as well once it's created. And these are where you want to start paying attention because here we have the Bottom and the Top. So sometimes they're just not always as straightforward. So, again, we could do this self. networkBottomConstraint = self. networkImageView, in this case it's our bottomAnchor, and we want a constraint, bottomAnchor. constraintEqualToAnchor, and it's our superview's topAnchor. Perfect! And then networkBottomConstraint. active = true. Great! Now that's added. And we're on our last one. We can go ahead and delete our addConstraints here. And we'll do self. networkLeadingConstraint = self. networkImageView, and it's the leadingAnchor, and it's going to be equal to our leadingAnchor of our parent view. And then we can go ahead and set active equal to true so it gets added to the View hierarchy. And now I'm just going to go up here and delete all the existing constraints, and you can see here, look at initializeViews. We can fit it on the screen here now, and this might look a little verbose, but it's so much simpler than working with the old NSLayoutConstraint. And not only that but we're utilizing this active property, which is going to go and find that common parent view for us and add the constraints so we don't need to do the bookkeeping. So, again, this is so much easier. Now if I go ahead and hit Command+R, run the app, you can see here that nothing has changed with our Profile Views here. We have the GitHub, the Medium one, and the Facebook one. And they're still laying out properly. We have the alignment rect, which is making sure that the profile images are aligning up properly. And our network icons are our decoration views for this view. So we're able to eliminate a lot of code. We're able to make it more readable. And we're able to use APIs which take a lot of the legwork away from us in terms of figuring out the common parent view between two different views. So Apple has done a great job in terms of simplifying what we need to accomplish building Auto Layout in code. And in a later course, we'll be looking at the visual format language, which is even more robust and lets us create more constraints, but this is definitely a huge leap forward in terms of simplicity.

UIStackView Playground
We're now going to take a look at the UIStackView. And what we're really going to try to stress here is the UIStackView behaves in predictable ways according to how Auto Layout works. And that's because under the hood, it's building constraints for you essentially. And it's taking care of creating these grid-based layouts for you and doing the heavy lifting so you don't have to create all the constraints to do that. So we have a playground here, and there're going to be a few pages that we go through throughout the video. You can see them here. And then I also have two source files. And let's quickly take a look at helper functions. So up here all I have are just some nice colors that we're going to use when we generate our views, nothing special. Then here is a generic function viewWithColor. And all it lets me do is I have this generic T, which is restricted to a UI subview, and I pass in a backgroundColor. And then I return the subview. So here I called it label, but it should be view. I create a T. I have access to the UIView initializer, and then I just set the backgroundColor and return it. And now I call this function repeatedly throughout the next several functions. So here I just have a stackViewWithFourLabels. So I'm going ahead and creating a viewWithColor, and I'm explicitly stating the type that I want returned back. In Swift you would need to do that because you can't do that on a function like in other languages like C#. And then I set the text and the textAlignment, and I do that for four labels. And then I go ahead and create UIStackView. I use the arrangedSubviews initializer to add the four views. And then I return the stackView. And you can call arrangedSubviews, insertArrangedSubviews, removeArrangedSubviews. And so that's how you add and remove views to the stack instead of the addSubview, removeSubview, like you would on a normal UI View. And then my other method here is stackViewWithFourViews. And I just create the four views, pass in the backgroundColors, and set up a new stackView. And then I have a stackViewWithFourDemoViews, and you can see here that I have four DemoViews. And we'll take a look at DemoView in a little bit. So go to the first file here. I'm going to open up the assistant editor so we can get our live rendering and also to get this nice formatted documentation. If you don't see it on yours, you can go ahead and check this checkbox or uncheck it of you want to edit it. So let's hide some of these menus. And so here I just create the stackView, and I have a stackViewWithFourLabels. And then I just go ahead and set some properties. So I set the frame, I set the axis, spacing for the stackView, the alignment, and the distribution. And then I leverage XCPlayground. And on this currentPage, I set the liveView equal to our stackView, which is how we're getting the rendering on the right here. So this is really cool. So now I can go ahead and do vertical spacing. I can increase the spacing within the views. And you can see here that the stackView is going ahead and taking care of distributing these views for us. And now it interacts with it in different ways. So something that we had done in our viewWithColor is every view that's being generated in all these examples is 100x100. But you can clearly see here that I created a frame with 400x400, and these labels are stretching all the way to it. And this is something that you want to get used to with UIStackView because either UIStackView is going to take care and size the views for you, or depending on some of the properties that you use, so if I set this to leading, it now is judging---it's now setting the width of all of our labels to the intrinsic content size of the label because it's definitely not as tall as our view, so it's not 100x100. And here you can say, well, you could do equal spacing. And now it's no longer stretching out the height of our views either. It's suddenly getting down to the intrinsic content size. And so you want to think about these things and what you've learned in the rendering pipeline as you're configuring these. And there are so many different combinations that you can come up with. So now the UI label is a nice example, but let's just take a look at the UI Views. So I'm going to go ahead and use that next link here. And now we're in our second playground page. And this is our method, the stackViewWithFourViews. And we don't see anything here. Now if I go ahead and I set the alignment to Fill, now we have all of our views, and they're horizontally stacked. Now do the same with vertical. Now here's a question: Why are we not seeing anything when I set this to Leading or Trailing or anything else? Well, you'll remember that the UI View has no intrinsic content size. And so the UIStackView has no idea what size to make it. And we can easily show this by taking a look at our DemoView. So we have this DemoView, and all it does is override the intrinsic content size, and we return a width of 200 and 100. And now if we use this in the prior module of our Profile View, it allows Auto Layout to be able to determine what a view's size should naturally be if it has no other information. And so if I jump to our UIStackView intrinsic content size page here, we have our stackViewWithFourDemoViews. And now if I go ahead and I change this to Leading, suddenly our UI Views are being sized appropriately because it can use that intrinsic content size to figure out what it should be doing. And we can easily prove this by adding a new view here that's just a UIView. So let's go ahead and create that. We'll give it a backgroundColor of, let's do a light gray. And then our stackView, and I will insertArrangedSubview and pass it into the third index. So now we have this big gaping space here. We don't even see any gray or anything. And if I go ahead and set this back to Fill, though, the UIStackView takes over and sizes the view for us. And now suddenly, we have a view. If I go ahead and set this to Trailing, and we set this to EqualSpacing, now you can see here it's trying---it at least is leaving double the padding because even though we don't see the view, we have the padding from between this view, between the yellow and our light gray view and the padding between the blue and the light gray view. So, again, the point is the UIStackView does leverage Auto Layout under the hood. And if you think about the properties that control Auto Layout, along with UIStackView, it will help you along the way, and you'll find things to be much more predictable than you would otherwise. And let's jump back into our Collaborate project, and let's use UIStackView for what it was truly made for, and that's deleting constraints out of Interface Builder and making our layouts more maintainable.

Updating Your Menu with UIStackView
So in this video, we're going to now replace our constraint-based layout for this menu and use a UIStackView instead. And so it's really easy. What we'll first do is we just want to clear all the constraints off this view. So I can come down to this bottom menu here and clear constraints. And make sure you select the bottom one. This will just do it for the selected view, and this will do it for all of them. So you can see here we no longer have any of our constraints. And then additionally what I can do is I can go ahead and select all of these views. And I can come here to our Stack button. And what this will do is it will go ahead and embed all of these in a stackView. So if I just click it, I now have them all lined up in a stackView. And you can see here I could switch it to horizontal or vertical. And I want it in the vertical position right now. So, I did lose my constraints here for the Scroll View as well, so I'm going to go ahead and pin the edges of the Scroll View to our parent view. And the next thing you would think is I could just go ahead and set the edges of this Stack View to the Scroll View, but this isn't going to work as we expect it to. If I go ahead and update the frames, you can see it forced it to the left corner here. Now why is that? Well, it's because the Scroll View doesn't have any intrinsic content size itself. And the Stack View sub-elements are establishing that. And so the Stack View's only going to be as wide as it needs to be. And this really isn't what we want here. Our original menu was kind of centered, and it took up the majority of width of the whole space. So is there any way we can fix this? Well there is. So I'm going to quickly undo my constraints here so you can see we're back to just having the Scroll View ones. And now what I'm going to do is I'm going to go ahead and select our Stack View, and I'm going to embed this in another view. So I'm going to create a Container View here within our Scroll View. And just to make it easier, we'll just call it Container View. And now I can go ahead and make this the same size as our Scroll View. And so we don't lose our backgroundColor, we can go ahead and set this properly. We'll just use a clear color to expedite it. And so, again, I'll just go ahead and pin our Container View to the Scroll View. And then the next step I'm going to take for this Container View is I'm going to make it equal widths with the Scroll View. And this is basically going to force our Container View to always be the width of the Scroll View, which the Scroll View's always the width of the parent view. So this is exactly what we're looking for. And now if I go ahead and I take our Stack View, and 0, 0, 0, and 0 on our Container View, and update the frames, now it's taking up the full width like we want it to. And, of course, there're still some spacing issues here. So you can go ahead and select the Stack View here and change the spacing, and there are lots of properties that you can modify. But if I go ahead and run this, you can see here on our iPhone 6+, we have a view. And if I scroll---if I go into landscape mode, I still have this properly spaced view and all the buttons listed out. And, of course, we could add some padding on the top and bottom to make it look better. This is great though. I mean, look what we went and did. We removed a lot of constraints, and we were able to replace them with this simple UIStackView. So it's a really cool addition to UI Kit. And if you really do have these grid-based layouts, it's going to be the easier solution versus building out the constraints yourself. And, again, though, it was important to learn the fundamentals of Auto Layout. Like our knowledge of intrinsic content size and how Auto Layout can automatically size certain views such as UI buttons and UI Image Views allowed us to quickly solve the problem of our UIStackView forcing itself to the corner here. So knowing Auto Layout and the fundamentals of Auto Layout allows you to leverage the UIStackView to its fullest potential. And using that knowledge of Auto Layout, you'll quickly be able to debug and fix any issues you might be having with the Stack View. And just remember, if you do have an odd layout that doesn't neatly fall into Stack View, you always have constraints to fall back on.

Summary
So we covered a lot of great material in this module. We looked at the active property. We saw how it's going to do a lot of the bookkeeping for us in terms of finding the right parent view and adding the constraints on our behalf. And if we set it to false, then it's going to do the opposite and find the parent view for us and remove that constraint so it no longer is calculated during the rendering pipeline. We then took a look at the new anchors that were added in iOS 9 and how it simplifies working with NSLayoutConstraint in code. Now while we haven't dived into the visual format language to really add as many constraints as we can, the NSLayoutAnchors are a great step between the NSLayoutConstraint API and the visual format language. It's much more concise, it's very readable, and if you have no reason to hold onto the reference of NSLayoutConstraint, you can simply just call the active property right afterwards and set it to true, and you're done. We went into our Collaborate project and updated the Profile View using the active property and these layout anchors. And we saw it was very easy to update the code. And we saw no changes in the way our UI laid out. Finally, we took a look at the UIStackView. And we really tried to analyze it from the standpoint of what we've learned in the prior modules between views having a specific size and the UIStackView being able to leverage that to size everything out properly and lay everything out. And now these are very composable. You can put a UIStackView vertically stacked, and you can have stacked views within them that are horizontally stacked. And you can lay out your user interface in a very grid-based layout. And, again, it was important, though, to go through this course without using it because by learning Auto Layout and all of the steps and the processes that happen underneath, there's very little magic to the UIStackView. It's simply just building those constraints on your behalf. And so whenever you feel like the UIStackView isn't doing what you're doing, you can think about the fundamentals that you have learned in this course and apply it to that problem. And I'm sure you will be able to solve why that UIStackView isn't behaving the way you expect it to. So, again, the point of this whole module was to simplify working with constraints. We were able to delete code by leveraging the active property and the NSLayoutAnchors. And we were able to delete constraints in Interface Builder by using the UIStackView.


